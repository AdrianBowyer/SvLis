<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="description" CONTENT="Introduction">
   <META NAME="keywords" CONTENT="svi2">
   <META NAME="resource-type" CONTENT="document">
   <META NAME="distribution" CONTENT="global">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.07 [en] (X11; I; Linux 2.0.36 i686) [Netscape]">
   <TITLE>Introduction </TITLE>
</HEAD>
<BODY BACKGROUND="svlis_new.gif">
<!--Converted with LaTeX2HTML 97.1 (release) (July 13th, 1997)
 by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippman, Marek Rouchal, Martin Wilck and others --><LINK REL="STYLESHEET" HREF="svi2.css"><LINK REL="next" HREF="node4.html"><LINK REL="previous" HREF="node2.html"><LINK REL="up" HREF="svi2.html"><LINK REL="next" HREF="node4.html"><!--Navigation Panel--><A NAME="tex2html135"></A><A NAME="tex2html135"></A><A NAME="tex2html135"></A><A NAME="tex2html135"></A><A NAME="tex2html135"></A><A NAME="tex2html135" HREF="node4.html"></A><A NAME="tex2html135" HREF="node4.html"></A><A NAME="tex2html135" HREF="node4.html"></A><A NAME="tex2html135" HREF="node4.html"></A><A HREF="node4.html" NAME="tex2html135"><IMG SRC="next_motif.gif" ALT="next" BORDER=0 HEIGHT=24 WIDTH=37 ALIGN=BOTTOM></A><A NAME="tex2html131"></A><A NAME="tex2html131"></A><A NAME="tex2html131"></A><A NAME="tex2html131"></A><A NAME="tex2html131"></A><A NAME="tex2html131" HREF="svi2.html"></A><A NAME="tex2html131" HREF="svi2.html"></A><A NAME="tex2html131" HREF="svi2.html"></A><A NAME="tex2html131" HREF="svi2.html"></A><A HREF="svi2.html" NAME="tex2html131"><IMG SRC="up_motif.gif" ALT="up" BORDER=0 HEIGHT=24 WIDTH=26 ALIGN=BOTTOM></A><A NAME="tex2html125"></A><A NAME="tex2html125"></A><A NAME="tex2html125"></A><A NAME="tex2html125"></A><A NAME="tex2html125"></A><A NAME="tex2html125" HREF="node2.html"></A><A NAME="tex2html125" HREF="node2.html"></A><A NAME="tex2html125" HREF="node2.html"></A><A NAME="tex2html125" HREF="node2.html"></A><A HREF="node2.html" NAME="tex2html125"><IMG SRC="previous_motif.gif" ALT="previous" BORDER=0 HEIGHT=24 WIDTH=63 ALIGN=BOTTOM></A><A NAME="tex2html133"></A><A NAME="tex2html133"></A><A NAME="tex2html133"></A><A NAME="tex2html133"></A><A NAME="tex2html133"></A><A NAME="tex2html133" HREF="node1.html"></A><A NAME="tex2html133" HREF="node1.html"></A><A NAME="tex2html133" HREF="node1.html"></A><A NAME="tex2html133" HREF="node1.html"></A><A HREF="node1.html" NAME="tex2html133"><IMG SRC="contents_motif.gif" ALT="contents" BORDER=0 HEIGHT=24 WIDTH=65 ALIGN=BOTTOM></A><A NAME="tex2html134"></A><A NAME="tex2html134"></A><A NAME="tex2html134"></A><A NAME="tex2html134"></A><A NAME="tex2html134"></A><A NAME="tex2html134" HREF="node11.html"></A><A NAME="tex2html134" HREF="node11.html"></A><A NAME="tex2html134" HREF="node11.html"></A><A NAME="tex2html134" HREF="node11.html"></A><A HREF="node11.html" NAME="tex2html134"><IMG SRC="index_motif.gif" ALT="index" BORDER=0 HEIGHT=24 WIDTH=43 ALIGN=BOTTOM></A>
<BR><B>Next:<A NAME="tex2html136"></A><A NAME="tex2html136"></A><A NAME="tex2html136"></A><A NAME="tex2html136"></A><A NAME="tex2html136"></A><A NAME="tex2html136" HREF="node4.html"></A><A NAME="tex2html136" HREF="node4.html"></A><A NAME="tex2html136" HREF="node4.html"></A><A NAME="tex2html136" HREF="node4.html"></A></B><A HREF="node4.html" NAME="tex2html136">Fundamental
geometric structures</A> <B>Up:<A NAME="tex2html132"></A><A NAME="tex2html132"></A><A NAME="tex2html132"></A><A NAME="tex2html132"></A><A NAME="tex2html132"></A><A NAME="tex2html132" HREF="svi2.html"></A><A NAME="tex2html132" HREF="svi2.html"></A><A NAME="tex2html132" HREF="svi2.html"></A><A NAME="tex2html132" HREF="svi2.html"></A></B><A HREF="svi2.html" NAME="tex2html132">SvLis
Introduction</A> <B>Previous:<A NAME="tex2html126"></A><A NAME="tex2html126"></A><A NAME="tex2html126"></A><A NAME="tex2html126"></A><A NAME="tex2html126"></A><A NAME="tex2html126" HREF="node2.html"></A><A NAME="tex2html126" HREF="node2.html"></A><A NAME="tex2html126" HREF="node2.html"></A><A NAME="tex2html126" HREF="node2.html"></A></B><A HREF="node2.html" NAME="tex2html126">Acknowledgements</A>
<P><!--End of Navigation Panel--><!--Table of Child-Links--><A NAME="CHILD_LINKS"></A><B>Subsections</B>
<UL>
<LI>
<A NAME="tex2html137"></A><A NAME="tex2html137"></A><A NAME="tex2html137"></A><A NAME="tex2html137"></A><A NAME="tex2html137"></A><A NAME="tex2html137" HREF="node3.html#SECTION00310000000000000000"></A><A NAME="tex2html137" HREF="node3.html#SECTION00310000000000000000"></A><A NAME="tex2html137" HREF="node3.html#SECTION00310000000000000000"></A><A NAME="tex2html137" HREF="node3.html#SECTION00310000000000000000"></A><A HREF="node3.html#SECTION00310000000000000000" NAME="tex2html137">Set-theoretic
modelling</A></LI>

<UL>
<LI>
<A NAME="tex2html138"></A><A NAME="tex2html138"></A><A NAME="tex2html138"></A><A NAME="tex2html138"></A><A NAME="tex2html138"></A><A NAME="tex2html138" HREF="node3.html#SECTION00311000000000000000"></A><A NAME="tex2html138" HREF="node3.html#SECTION00311000000000000000"></A><A NAME="tex2html138" HREF="node3.html#SECTION00311000000000000000"></A><A NAME="tex2html138" HREF="node3.html#SECTION00311000000000000000"></A><A HREF="node3.html#SECTION00311000000000000000" NAME="tex2html138">Primitives
and half-spaces</A></LI>
</UL>

<LI>
<A NAME="tex2html139"></A><A NAME="tex2html139"></A><A NAME="tex2html139"></A><A NAME="tex2html139"></A><A NAME="tex2html139"></A><A NAME="tex2html139" HREF="node3.html#SECTION00320000000000000000"></A><A NAME="tex2html139" HREF="node3.html#SECTION00320000000000000000"></A><A NAME="tex2html139" HREF="node3.html#SECTION00320000000000000000"></A><A NAME="tex2html139" HREF="node3.html#SECTION00320000000000000000"></A><A HREF="node3.html#SECTION00320000000000000000" NAME="tex2html139">Design
philosophy and overview</A></LI>
</UL>
<!--End of Table of Child-Links-->
<CENTER>
<P>Copyright &copy; 1994, 1996, 1999 <A HREF="http://www.inge.com">Information
Geometers Ltd </A>and <A HREF="http://www.bath.ac.uk">The University of
Bath</A></CENTER>

<BR>&nbsp;
<P><BR>
<BR>
<BR>
<P>
<HR>
<H1>
<A NAME="SECTION00300000000000000000"></A><B><FONT SIZE=+4>Introduction</FONT></B></H1>
<A NAME="CH1"></A>SvLis is a kernel geometric modeller<A NAME="334"></A>&nbsp;
written in C<FONT SIZE=-1>++</FONT>. The kernel bit just means that it
is a library of header files and procedures which you can build into your
own applications programs.
<P>What is a geometric modeller?<A NAME="335"></A><A NAME="GSDIFF"></A>&nbsp;
Let's start with solid modelling. A solid modeller is a computer program
for representing solid objects. Armed with such a program, you can make
pictures of the objects, work out their volume, try to decide automatically
how to assemble them, or do a number of other useful things.
<P>Geometric modellers like svLis are solid modellers and more. We'll come
to the `more' in Chapter 3<A HREF="node5.html#SECTION00540000000000000000"><IMG SRC="foot_motif.gif" ALT="[*]" BORDER=1 HEIGHT=10 WIDTH=10 ALIGN=BOTTOM></A>.
For now let's use svLis and C<FONT SIZE=-1>++</FONT> to make a model of
a solid cube<A NAME="337"></A><A NAME="338"></A>&nbsp; with one corner
at the origin and another at the point (1,1,1).
<UL>
<PRE>#include &lt;svlis.h>

int main()
{
// Start Svlis.

&nbsp; svlis_init();

// Define the corners.

&nbsp; sv_point corner_a = sv_point(0,0,0);
&nbsp; sv_point corner_b = sv_point(1,1,1);

// Make the cube; it will be a set
// (of which more in a moment).

&nbsp; sv_set lump = cuboid(corner_a, corner_b);

// Write it to a file.

&nbsp; ofstream f("my_little_cube.set");
&nbsp; f &lt;&lt; lump;
&nbsp; f.close();</PRE>

<PRE>// Tidy up Svlis</PRE>

<PRE>&nbsp; return(svlis_end(0));
}</PRE>
</UL>
Once you have included the <TT>svlis.h</TT> header file, you can just code
up what you want using perfectly straightforward C<FONT SIZE=-1>++<A NAME="340"></A></FONT>
. As you can imagine, <TT>sv_point<A NAME="tex2html1"></A><A NAME="tex2html1"></A><A NAME="tex2html1"></A><A NAME="tex2html1"></A><A NAME="tex2html1"></A><A NAME="tex2html1" HREF="footnode.html#591"></A><A NAME="tex2html1" HREF="footnode.html#591"></A><A NAME="tex2html1" HREF="footnode.html#591"></A><A NAME="tex2html1" HREF="footnode.html#591"></A><A HREF="footnode.html#591" NAME="tex2html1"><IMG SRC="foot_motif.gif" ALT="[*]" BORDER=1 HEIGHT=10 WIDTH=10 ALIGN=BOTTOM></A><A NAME="592"></A><A NAME="593"></A><A NAME="594"></A><A NAME="595"></A></TT>
is a svLis <TT>struct</TT> that<A NAME="FIRSTPT"></A>&nbsp; records points
(see Page&nbsp;<A HREF="node4.html#PTDEF"><IMG SRC="cross_ref_motif.gif" ALT="[*]" BORDER=1 HEIGHT=10 WIDTH=10 ALIGN=BOTTOM></A>),
and <TT>sv_set<A NAME="596"></A><A NAME="597"></A></TT>&nbsp; is the svLis
<TT>class</TT>
for solids (and other things--again, for more details see Chapter 3<A HREF="node5.html#SECTION00540000000000000000"><IMG SRC="foot_motif.gif" ALT="[*]" BORDER=1 HEIGHT=10 WIDTH=10 ALIGN=BOTTOM></A>).
<P>Writing the cube to a file is, perhaps, the dullest thing we could have
done with it. And as gripping entertainment, the cube itself lacks something.
We could make it a bit more interesting by cutting a cylindrical hole<A NAME="354"></A><A NAME="355"></A><A NAME="CYLFN"></A>
through it along a diagonal:
<UL>
<PRE>// ...

// Define an axis;
// let's use the cube's leading diagonal.

&nbsp; sv_line axis = sv_line(corner_b, corner_a);

// Make a cylinder along the axis
// with a radius of, say, 0.2.

&nbsp; sv_set cyl = cylinder(axis, 0.2);

// Subtract the cylinder from the cube.

&nbsp; lump = lump - cyl;

// ....</PRE>
</UL>
Again, <TT>sv_line<A NAME="598"></A><A NAME="599"></A></TT>&nbsp; is a
svLis <TT>struct</TT> (see Page&nbsp;<A HREF="node4.html#LINDEF"><IMG SRC="cross_ref_motif.gif" ALT="[*]" BORDER=1 HEIGHT=10 WIDTH=10 ALIGN=BOTTOM></A>).
To define a line we need a direction vector<A NAME="362"></A>&nbsp; (<TT>corner_b</TT>
in the example), and any point through which the line passes (<TT>corner_a</TT>
in the example).
<P>We can get svLis to draw a picture of the semi-infinite set of points
in space that we've created: that is, a picture of the cube punctured by
a diagonal hole. There are a number of different techniques you could use
to get svLis to draw pictures. One of the fastest is to create a collection
of polygons<A NAME="365"></A>&nbsp; that very nearly approximate the surface
of the set. Making the polygons is called <I>faceting<A NAME="367"></A></I>
, and a faceting ability is built into svLis. The resulting polygons can
readily be viewed using standard computer graphics<A NAME="368"></A>&nbsp;
display<A NAME="369"></A><A NAME="370"></A>&nbsp; techniques. The ability
to display polygons is available in the hardware of many modern workstations.
<P>In order to facet a set, in this case the cube with a hole, svLis needs
to know where in space to start work. We define this region of interest
as a <I>box</I>,<A NAME="372"></A><A NAME="373"></A>&nbsp; aligned with
the coordinate axes. The set and the box together make a <I>model</I>.
The present region of interest might extend from the point (-1, -1, -1)
to the point (2, 2, 2). (We define a box in the same way as a cube, by
specifying two corners on its leading diagonal.) The faceting code is:
<UL>
<PRE>// ...

&nbsp; corner_a = sv_point(-1, -1, -1);
&nbsp; corner_b = sv_point(2, 2, 2);
&nbsp; sv_box interesting = sv_box(corner_a, corner_b);

// Make the model by combining the shape
// and the region of interest.

&nbsp; sv_model m = sv_model(lump, interesting);

// Facet the model m - this makes the polygons - then
// plot the picture of the polygons.

&nbsp; m = m.facet();
&nbsp; plot_m_p_gons(m);

// ....</PRE>
</UL>
The sort of picture you get as a result of calling <TT>plot_m_p_gons<A NAME="600"></A><A NAME="601"></A></TT>&nbsp;
depends on the type of computer on which you're running svLis. On my Silicon
Graphics it made the picture shown in Figure <A HREF="node3.html#fig:CUBEHOLE">1</A>.
<BR>&nbsp;
<BR>&nbsp;
<BR>
<BR>
<BR>
<CENTER>
<P><A NAME="fig:CUBEHOLE"></A><IMG SRC="img1.gif" ALT="\begin{figure}% latex2html id marker 381\epsfysize=80mm\centerline{\epsffile{... ...ith a cylindrical hole along one diagonal.\end{minipage}\end{center}\end{figure}" HEIGHT=325 WIDTH=451></CENTER>

<BR>&nbsp;
<P><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<P>At this point the perceptive and attentive reader (hello!) may be wondering
how the box and the cuboid functions differ. This is explained on Page&nbsp;<A HREF="node9.html#BOXCUBE"><IMG SRC="cross_ref_motif.gif" ALT="[*]" BORDER=1 HEIGHT=10 WIDTH=10 ALIGN=BOTTOM></A>.
For now, let's worry about why our solid lump was held in a svLis class
called <TT>sv_set</TT>.
<BR>&nbsp;
<BR>&nbsp;
<BR>&nbsp;
<H1>
<A NAME="SECTION00310000000000000000"></A>Set-theoretic modelling</H1>
<A NAME="VENNST"></A>SvLis is a pure set-theoretic geometric modeller<A NAME="389"></A><A NAME="tex2html2"></A><A NAME="tex2html2"></A><A NAME="tex2html2"></A><A NAME="tex2html2"></A><A NAME="tex2html2"></A><A NAME="tex2html2" HREF="footnode.html#603"></A><A NAME="tex2html2" HREF="footnode.html#603"></A><A NAME="tex2html2" HREF="footnode.html#603"></A><A NAME="tex2html2" HREF="footnode.html#603"></A><A HREF="footnode.html#603" NAME="tex2html2"><IMG SRC="foot_motif.gif" ALT="[*]" BORDER=1 HEIGHT=10 WIDTH=10 ALIGN=BOTTOM></A>.
It treats geometry as a three-dimensional Venn diagram<A NAME="395"></A>
. SvLis takes simple shapes and puts them together to make more complicated
ones by using the operators of set-theory.
<P>There are four operators:<A NAME="396"></A><A NAME="397"></A><A NAME="398"></A><A NAME="399"></A><A NAME="400"></A><A NAME="401"></A><A NAME="402"></A><A NAME="403"></A><A NAME="404"></A><A NAME="405"></A>
<DL>
<DD>
<I>Union:&nbsp;<IMG SRC="img2.gif" ALT="$\cup$" HEIGHT=12 WIDTH=10 ALIGN=BOTTOM>
(or </I><B><TT>|</TT></B><I> in svLis).</I></DD>

<DD>
<I>Intersection:&nbsp;<IMG SRC="img3.gif" ALT="$\cap$" HEIGHT=12 WIDTH=10 ALIGN=BOTTOM>
(or <B><TT>&amp;</TT></B> in svLis).</I></DD>

<DD>
<I>Difference: <B>-</B> in both mathematical and svLis notation.</I></DD>

<DD>
<I>Symmetric difference:&nbsp;<IMG SRC="img4.gif" ALT="$\Delta$" HEIGHT=12 WIDTH=12 ALIGN=BOTTOM>
(or&nbsp;<IMG SRC="img5.gif" ALT="$ \wedge $" HEIGHT=12 WIDTH=10 ALIGN=BOTTOM>
in svLis).</I></DD>
</DL>
<A NAME="604"></A><A NAME="605"></A><A NAME="606"></A><A NAME="607"></A><A NAME="608"></A><A NAME="609"></A><A NAME="610"></A><A NAME="611"></A>
<BR>&nbsp;
<P>The usual two-dimensional Venn diagram<A NAME="424"></A>&nbsp; for all
these is shown in Figure <A HREF="node3.html#fig:VENN">2</A>.
<BR>&nbsp;
<BR>&nbsp;
<BR>
<BR>
<BR>
<CENTER>
<P><A NAME="fig:VENN"></A><IMG SRC="img7.gif" ALT="\begin{figure}% latex2html id marker 426\epsfysize=80mm\centerline{\epsffile{... ...le alternative (see Page~\pageref{BOOLP}).\end{minipage}\end{center}\end{figure}" HEIGHT=474 WIDTH=455></CENTER>

<BR>&nbsp;
<P><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<P>We've already seen the difference operator in action. I used it to make
the cylindrical hole in the cube with the program line:
<BR>&nbsp;
<BLOCKQUOTE><TT>lump = lump - cyl;</TT></BLOCKQUOTE>

<P><BR>Instead, I could have intersected the shapes, defining the region
in space where both were solid, or unioned them, defining the region where
either or both were solid. The results are shown in Figure <A HREF="node3.html#fig:CICU">3</A>.
<BR>&nbsp;
<BR>&nbsp;
<BR>
<BR>
<BR>
<CENTER>
<P><A NAME="fig:CICU"></A><IMG SRC="img8.gif" ALT="\begin{figure}% latex2html id marker 440\epsfysize=80mm\centerline{\epsffile{... ...when the model, called {\tt m}, wasmade. \end{minipage}\end{center}\end{figure}" HEIGHT=574 WIDTH=558></CENTER>

<BR>&nbsp;
<P><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<P><A NAME="BOOLP"></A>If you are still as perceptive and attentive as
you were a few paragraphs ago, you've probably spotted the relationship
between the operators of set-theory and those of Boolean logic<A NAME="450"></A><A NAME="451"></A>
. Intersection gives you the part of space where the two things being intersected
are <I>both</I> solid, just as the <FONT SIZE=-1>AND<A NAME="635"></A><A NAME="636"></A></FONT>&nbsp;
of two bits of data only gives you a <TT>1</TT> when both bits are <TT>1</TT>.
Similarly, union gives you solid where <I>either or both</I> of the two
things being unioned are solid, just as the <FONT SIZE=-1>OR<A NAME="637"></A><A NAME="638"></A></FONT>&nbsp;
operator gives you a <TT>1</TT> when either or both of the two bits being
<FONT SIZE=-1>OR</FONT>ed
are <TT>1</TT>. If you look back at the Venn diagram in Figure <A HREF="node3.html#fig:VENN">2</A>
you will also be able to see the relationship between the symmetric difference
operator and the exclusive-<FONT SIZE=-1> OR<A NAME="639"></A><A NAME="640"></A><A NAME="641"></A><A NAME="642"></A></FONT>&nbsp;
operator. It is because of all this that you will sometimes see set-theoretic
geometric modellers called Boolean modellers<A NAME="474"></A><A NAME="475"></A>&nbsp;
in the literature<A NAME="tex2html3"></A><A NAME="tex2html3"></A><A NAME="tex2html3"></A><A NAME="tex2html3"></A><A NAME="tex2html3"></A><A NAME="tex2html3" HREF="footnode.html#643"></A><A NAME="tex2html3" HREF="footnode.html#643"></A><A NAME="tex2html3" HREF="footnode.html#643"></A><A NAME="tex2html3" HREF="footnode.html#643"></A><A HREF="footnode.html#643" NAME="tex2html3"><IMG SRC="foot_motif.gif" ALT="[*]" BORDER=1 HEIGHT=10 WIDTH=10 ALIGN=BOTTOM></A><A NAME="644"></A>
.
<P>Internally, svLis recodes <B><TT>-<A NAME="482"></A></TT></B>and&nbsp;<IMG SRC="img5.gif" ALT="$ \wedge $" HEIGHT=12 WIDTH=10 ALIGN=BOTTOM><A NAME="484"></A>&nbsp;
whenever you use them, by means of the following rewriting rules:
<P><IMG SRC="img9.gif" ALT="$\textstyle\parbox{\textwidth}{\begin{eqnarray*}A - B & = & A \cap \bar{B}\ A \wedge B & = & (A \cap \bar{B}) \cup (B \cap \bar{A}).\end{eqnarray*}}$" HEIGHT=66 WIDTH=397 ALIGN=CENTER>
<P>(The bar means set-complement; draw a Venn diagram of your own if you
need to be convinced that these work.) As a result, internally svLis only
has the operators&nbsp;<IMG SRC="img2.gif" ALT="$\cup$" HEIGHT=12 WIDTH=10 ALIGN=BOTTOM>
and&nbsp;<IMG SRC="img3.gif" ALT="$\cap$" HEIGHT=12 WIDTH=10 ALIGN=BOTTOM>
to deal with, which makes all sorts of things simpler, easier, and more
efficient (though it does use up more memory--see Page&nbsp;<A HREF="node3.html#MEMWASTE"><IMG SRC="cross_ref_motif.gif" ALT="[*]" BORDER=1 HEIGHT=10 WIDTH=10 ALIGN=BOTTOM></A>).
<P>You will have noticed that I didn't include a picture of the symmetric
difference<A NAME="493"></A><A NAME="494"></A>&nbsp; of the cube and the
cylinder in Figure <A HREF="node3.html#fig:CICU">3</A>. The reason is that,
seen from the outside, the symmetric difference of two solids looks just
like their union. However, the symmetric difference has a void in the middle
that the union doesn't have (look at Figure <A HREF="node3.html#fig:VENN">2</A>
again if you need to be convinced). How could we examine the void which
the symmetric difference creates?
<H2>
<A NAME="SECTION00311000000000000000"></A>Primitives and half-spaces</H2>
<A NAME="PRIMHSP"></A>Suppose I sliced through the model with a knife,
cutting it in two, and then looked at one of the halves. The void would
be as obvious as half a grub in an apple. Before getting svLis to do this
chopping operation, we need to make a small detour to introduce
<I>primitives</I>
and <I>half-spaces<A NAME="501"></A><A NAME="502"></A></I>.
<P>Take a piece of svLis set-theory, such as
<UL>&nbsp;
<BR><TT>( (a &amp; b) - (c | d) )&nbsp;<IMG SRC="img5.gif" ALT="$ \wedge $" HEIGHT=12 WIDTH=10 ALIGN=BOTTOM>
e</TT></UL>
Like any algebraic expression, it can be written as a tree<A NAME="504"></A><A NAME="505"></A>,
as shown in Figure <A HREF="node3.html#fig:OP_TREE">4</A>. The variables
<TT>a</TT>
and <TT>b</TT> and so on might represent sets with very complicated shapes,
but--if we were to replace them with <I>their</I> trees, and so on--we
would eventually arrive at leaves which could not be simplified further.
A primitive in svLis is such a solid<A NAME="tex2html4"></A><A NAME="tex2html4"></A><A NAME="tex2html4"></A><A NAME="tex2html4"></A><A NAME="tex2html4"></A><A NAME="tex2html4" HREF="footnode.html#510"></A><A NAME="tex2html4" HREF="footnode.html#510"></A><A NAME="tex2html4" HREF="footnode.html#510"></A><A NAME="tex2html4" HREF="footnode.html#510"></A><A HREF="footnode.html#510" NAME="tex2html4"><IMG SRC="foot_motif.gif" ALT="[*]" BORDER=1 HEIGHT=10 WIDTH=10 ALIGN=BOTTOM></A>
that cannot be broken down into simpler solids.
<BR>&nbsp;
<BR>&nbsp;
<BR>
<BR>
<BR>
<CENTER>
<P><A NAME="fig:OP_TREE"></A><IMG SRC="img10.gif" ALT="\begin{figure}% latex2html id marker 511\epsfysize=80mm\centerline{\epsffile{... ...ators at the nodes and operands asleaves.\end{minipage}\end{center}\end{figure}" HEIGHT=373 WIDTH=517></CENTER>

<BR>&nbsp;
<P><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<P>The cylinder that we first encountered on Page&nbsp;<A HREF="node3.html#CYLFN"><IMG SRC="cross_ref_motif.gif" ALT="[*]" BORDER=1 HEIGHT=10 WIDTH=10 ALIGN=BOTTOM></A>
was a primitive<A NAME="517"></A><A NAME="518"></A>. Indeed, instead of
typing <TT>sv_set cyl = cylinder(axis, 0.2);<A NAME="tex2html5"></A><A NAME="tex2html5"></A><A NAME="tex2html5"></A><A NAME="tex2html5"></A><A NAME="tex2html5"></A><A NAME="tex2html5" HREF="footnode.html#626"></A><A NAME="tex2html5" HREF="footnode.html#626"></A><A NAME="tex2html5" HREF="footnode.html#626"></A><A NAME="tex2html5" HREF="footnode.html#626"></A><A HREF="footnode.html#626" NAME="tex2html5"><IMG SRC="foot_motif.gif" ALT="[*]" BORDER=1 HEIGHT=10 WIDTH=10 ALIGN=BOTTOM></A></TT>
I could have (rather laboriously) constructed it by typing
<UL>
<PRE>sv_primitive cyl_prim = p_cylinder(axis, 0.2);
sv_set cyl = sv_set(cyl_prim);</PRE>
</UL>
The prefix <TT>p_</TT> is there to distinguish the function that returns
a cylinder primitive<A NAME="627"></A><A NAME="628"></A>&nbsp; from the
one that returns a cylinder set as C++ won't allow you to overload functions
by their return value alone. Indeed, the <TT>cylinder</TT> set function
does little more than those last two lines of code. Thus we have a hierarchy,
with primitives at the bottom, sets (which may be just one primitive, or
a combination of many) above them, and models (which are boxes containing
one or more sets) above <I>them</I>. This is illustrated in Figure <A HREF="node3.html#fig:HIER">5</A>.
(We'll see how to put more than one set into a model in Chapter 4.)
<BR>&nbsp;
<BR>&nbsp;
<BR>
<BR>
<BR>
<CENTER>
<P><A NAME="fig:HIER"></A><IMG SRC="img11.gif" ALT="\begin{figure}% latex2html id marker 528\epsfysize=80mm\centerline{\epsffile{... ...chy of the major \mbox{svLis}\ structures.\end{minipage}\end{center}\end{figure}" HEIGHT=362 WIDTH=511></CENTER>

<BR>&nbsp;
<P><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<P>There are other primitives in svLis: for example the sphere, <TT>sv_primitive
p_sphere(sv_point centre, sv_real radius)</TT>.<A NAME="533"></A><A NAME="534"></A>However,
the cube through which I drilled a hole was <I>not</I> a primitive. SvLis
made it by intersecting together six <I>planar half-spaces<A NAME="537"></A></I>.
A planar half-space is the simplest primitive in svLis. It is a flat plane
in space that has solid on one side and nothing on the other. The solid
and the nothing both extend to infinity away from the plane<A NAME="tex2html6"></A><A NAME="tex2html6"></A><A NAME="tex2html6"></A><A NAME="tex2html6"></A><A NAME="tex2html6"></A><A NAME="tex2html6" HREF="footnode.html#630"></A><A NAME="tex2html6" HREF="footnode.html#630"></A><A NAME="tex2html6" HREF="footnode.html#630"></A><A NAME="tex2html6" HREF="footnode.html#630"></A><A HREF="footnode.html#630" NAME="tex2html6"><IMG SRC="foot_motif.gif" ALT="[*]" BORDER=1 HEIGHT=10 WIDTH=10 ALIGN=BOTTOM></A>.
Indeed, so simple and fundamental are planar half-spaces that svLis has
a special
<TT>struct</TT> called <TT>sv_plane<A NAME="631"></A><A NAME="632"></A></TT>&nbsp;
for holding them:
<UL>
<PRE>sv_point n_vector = sv_point(-1, 1, 0);
sv_point through = sv_point(0, 0, 0);
sv_plane f = sv_plane(n_vector, through);</PRE>
</UL>
To define a plane, you need to supply its <I>normal vector<A NAME="544"></A></I>&nbsp;
(called <TT>n_vector</TT> in the example) and any&nbsp;<A NAME="PLANEDEF"></A>point
in space through which the plane passes (called <TT>through</TT> in the
example). The normal vector is a vector at right angles to the plane; by
convention it points from solid to air. In the example just given the plane
is vertical (by which I mean that it's parallel to the <I>z</I>-axis<A NAME="tex2html7"></A><A NAME="tex2html7"></A><A NAME="tex2html7"></A><A NAME="tex2html7"></A><A NAME="tex2html7"></A><A NAME="tex2html7" HREF="footnode.html#548"></A><A NAME="tex2html7" HREF="footnode.html#548"></A><A NAME="tex2html7" HREF="footnode.html#548"></A><A NAME="tex2html7" HREF="footnode.html#548"></A><A HREF="footnode.html#548" NAME="tex2html7"><IMG SRC="foot_motif.gif" ALT="[*]" BORDER=1 HEIGHT=10 WIDTH=10 ALIGN=BOTTOM></A>),
and it slices through the <I>xy</I> plane along the line <I>x</I> = <I>y</I>.
(The axis of that cylinder that we had lies in it, too. . . .) Of course
I can now make the plane into a primitive, and that primitive into a set:
<UL>
<PRE>sv_primitive p_f = sv_primitive(f);
sv_set s_p_f = sv_set(p_f);</PRE>
</UL>

<CENTER>
<P><BR><A NAME="fig:SDIFFSECT"></A><IMG SRC="img12.gif" ALT="\begin{figure}% latex2html id marker 549\epsfysize=80mm\centerline{\epsffile{... ...-plane inwhich the cylinder's axis lies. \end{minipage}\end{center}\end{figure}" HEIGHT=432 WIDTH=452></CENTER>

<BR>&nbsp;
<P><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<P>A half-space is called a half-space because it divides all of space<A NAME="HPLANE"></A>into
two regions: a semi-infinite solid part, and a semi-infinite air part.
Anything that partitions space in this way is called a half-space. The
cylinder is a half-space, for example: it defines two infinite parts--a
long thin solid one, and an air one that is everywhere else. Indeed, all
svLis primitives are half-spaces (as are most svLis sets; we'll come to
two that aren't in a minute).
<P>Now we've been on that diversion, let's return to looking at the void
in the symmetric difference of the cube and the cylinder. How can we make
the cut that exposes the half-grub in the apple?
<P>Suppose I were to intersect the result of the symmetric difference operation
with the half-plane that I just created:&nbsp;<A NAME="SYMDIFEX"></A>
<UL>
<PRE>lump = lump ^ cyl;
lump = lump &amp; s_p_f;
m = sv_model(lump, interesting);
m = m.facet();
plot_m_p_gons(m);</PRE>
</UL>
That was rather longwinded, and I could obviously have compressed it into
two or three lines. But I have left it like that because it's easier to
read and to understand. The picture that the call to <TT>plot_m_p_gons</TT>
produces is shown in Figure <A HREF="node3.html#fig:SDIFFSECT">6</A>.
<P>The effect is to remove the parts of the cube and cylinder that lie
in the region on the air side of the half-plane, thus creating a section.
<BR>&nbsp;
<BR>&nbsp;
<BR>&nbsp;
<H1>
<A NAME="SECTION00320000000000000000"></A>Design philosophy and overview</H1>
<A NAME="DESPHIL"></A>I have just opened another window on my computer.
In it, I'm finding out the size of the executable code and libraries for
the windows system itself. They are 43 megabytes long. Now. I wouldn't
be seen dead writing<A NAME="MEMWASTE"></A>&nbsp; an operating system,
but this seems like a lot to me. In view of this, almost everywhere in
svLis, space<A NAME="561"></A>&nbsp; is sacrificed to speed. If other people
can increase sales for memory and disc manufacturers, then so can I. Quite
large pieces of svLis code are defined as inline in <TT>.h</TT> files to
save call overheads, many loops<A NAME="563"></A>&nbsp; are expanded, and
lookup<A NAME="564"></A>&nbsp; tables are used to effect speedups. Incidentally,
the svLis library takes up about 4 megabytes (on a PC under Linux--it is
slightly different on other machines).
<P>SvLis has a number of <TT>struct</TT>s and <TT>class</TT>es, of course.
Generally, simple ones like <TT>sv_point</TT>s have public data<A NAME="568"></A>&nbsp;
which you can get at directly if you want. The more complicated ones, such
as <TT>sv_set</TT>s, for example, hide their data<A NAME="570"></A>, and
provide you with functions so you can get at values without making a mess.
<P>SvLis aims to be completely consistent in its use of object-orientation<A NAME="571"></A>;
when some action, say, rotates an <TT>sv_plane</TT> then the same action
will also rotate a whole <TT>sv_set</TT>, and so on. Also, any operation
that makes sense is defined, so, for example, if you add an <TT>sv_point</TT>
to just about anything, that thing is translated to a new place in space.
For consistency, one or two operations that don't make a lot of sense are
defined as well: such as taking <I>e</I> to the power of an <TT>sv_box</TT>.
Doubtless someone will find a use for these. . . .
<P>SvLis is what is called a <I>kernel</I> modeller<A NAME="577"></A><A NAME="tex2html8"></A><A NAME="tex2html8"></A><A NAME="tex2html8"></A><A NAME="tex2html8"></A><A NAME="tex2html8"></A><A NAME="tex2html8" HREF="footnode.html#578"></A><A NAME="tex2html8" HREF="footnode.html#578"></A><A NAME="tex2html8" HREF="footnode.html#578"></A><A NAME="tex2html8" HREF="footnode.html#578"></A><A HREF="footnode.html#578" NAME="tex2html8"><IMG SRC="foot_motif.gif" ALT="[*]" BORDER=1 HEIGHT=10 WIDTH=10 ALIGN=BOTTOM></A>:
that is to say that you're not forced to use a fancy windows-driven interface--you
can incorporate svLis into your own code; nor does svLis come bundled with
manufacturing applications etc. What it <I>does</I> provide is a consistent,
efficient, and user-expandable representation for a wide variety of shapes,
and the low-level functions for manipulating and interrogating those shapes.
The idea is that you, the user, can employ it as the core of your geometric
modelling application and write front ends and high-level functions based
on (sometimes very many) calls to the low-level ones. Your application
may be a product or it may be software that provides functionality to other
application-builders in turn.
<P>The svLis procedures and functions are available as a library. Applications
make calls to this library, and for this reason the procedures and functions
are named the <I>Applications Programming Interface</I>, or <FONT SIZE=-1>API<A NAME="645"></A></FONT>&nbsp;
for short.
<P>What do I mean by the phrase `wide range of shapes'? So far, all we
have seen are flat surfaces and cylinders. SvLis can, in fact, represent
any solid that can be expressed as an implicit polynomial<A NAME="583"></A>&nbsp;
inequality up to a polynomial degree of about eight<A NAME="584"></A><A NAME="585"></A>.
(The `about' here is because some polynomials are more numerically stable
than others.) This is explained in more detail in Chapter 3. All I shall
say here that this includes all the usual engineering shapes (planes, cones,
cylinders, spheres, tori and cyclides) as well as more complicated surfaces.
SvLis allows you to blend these shapes to make fillets and smooth transitions
from one to another. SvLis also allows you to use the sine, cosine, and
exponential functions when building descriptions of shapes.
<P>Shapes in svLis don't have to be solids occupying real volume. You can
make curved or flat sheets of zero thickness, and curved or straight lines,
and points. All of these, together with the solids, can be combined using
the set-theory that we have already seen to make membranes with holes in,
curved lines with breaks, grids of points and so on, in a completely consistent
way.
<P>SvLis also allows you to define your own shapes by writing C<FONT SIZE=-1>++</FONT>
functions<A NAME="586"></A>. This means that, even if you can't work out
(or there isn't) the algebra to define a shape, as long as you can write
some code that can tell for any point whether it's inside or outside your
shape, and you can have a hack at generating a gradient vector for it,
then svLis can incorporate it into models, create blends onto it, and indeed
do just about anything with it that can be done with the internal polynomial
shapes.
<P>SvLis is intended primarily for use in traditional <FONT SIZE=-1>CADCAM<A NAME="588"></A></FONT>&nbsp;
areas like engineering and architecture. But its inherent versatility and
its ability to allow user-programmed shapes should also allow it to be
used in diverse fields such as medicine, data visualization, and archaeology.
<P>
<HR><!--Navigation Panel--><A NAME="tex2html135"></A><A NAME="tex2html135"></A><A NAME="tex2html135"></A><A NAME="tex2html135"></A><A NAME="tex2html135"></A><A NAME="tex2html135" HREF="node4.html"></A><A NAME="tex2html135" HREF="node4.html"></A><A NAME="tex2html135" HREF="node4.html"></A><A NAME="tex2html135" HREF="node4.html"></A><A HREF="node4.html" NAME="tex2html135"><IMG SRC="next_motif.gif" ALT="next" BORDER=0 HEIGHT=24 WIDTH=37 ALIGN=BOTTOM></A><A NAME="tex2html131"></A><A NAME="tex2html131"></A><A NAME="tex2html131"></A><A NAME="tex2html131"></A><A NAME="tex2html131"></A><A NAME="tex2html131" HREF="svi2.html"></A><A NAME="tex2html131" HREF="svi2.html"></A><A NAME="tex2html131" HREF="svi2.html"></A><A NAME="tex2html131" HREF="svi2.html"></A><A HREF="svi2.html" NAME="tex2html131"><IMG SRC="up_motif.gif" ALT="up" BORDER=0 HEIGHT=24 WIDTH=26 ALIGN=BOTTOM></A><A NAME="tex2html125"></A><A NAME="tex2html125"></A><A NAME="tex2html125"></A><A NAME="tex2html125"></A><A NAME="tex2html125"></A><A NAME="tex2html125" HREF="node2.html"></A><A NAME="tex2html125" HREF="node2.html"></A><A NAME="tex2html125" HREF="node2.html"></A><A NAME="tex2html125" HREF="node2.html"></A><A HREF="node2.html" NAME="tex2html125"><IMG SRC="previous_motif.gif" ALT="previous" BORDER=0 HEIGHT=24 WIDTH=63 ALIGN=BOTTOM></A><A NAME="tex2html133"></A><A NAME="tex2html133"></A><A NAME="tex2html133"></A><A NAME="tex2html133"></A><A NAME="tex2html133"></A><A NAME="tex2html133" HREF="node1.html"></A><A NAME="tex2html133" HREF="node1.html"></A><A NAME="tex2html133" HREF="node1.html"></A><A NAME="tex2html133" HREF="node1.html"></A><A HREF="node1.html" NAME="tex2html133"><IMG SRC="contents_motif.gif" ALT="contents" BORDER=0 HEIGHT=24 WIDTH=65 ALIGN=BOTTOM></A><A NAME="tex2html134"></A><A NAME="tex2html134"></A><A NAME="tex2html134"></A><A NAME="tex2html134"></A><A NAME="tex2html134"></A><A NAME="tex2html134" HREF="node11.html"></A><A NAME="tex2html134" HREF="node11.html"></A><A NAME="tex2html134" HREF="node11.html"></A><A NAME="tex2html134" HREF="node11.html"></A><A HREF="node11.html" NAME="tex2html134"><IMG SRC="index_motif.gif" ALT="index" BORDER=0 HEIGHT=24 WIDTH=43 ALIGN=BOTTOM></A>
<BR><B>Next:<A NAME="tex2html136"></A><A NAME="tex2html136"></A><A NAME="tex2html136"></A><A NAME="tex2html136"></A><A NAME="tex2html136"></A><A NAME="tex2html136" HREF="node4.html"></A><A NAME="tex2html136" HREF="node4.html"></A><A NAME="tex2html136" HREF="node4.html"></A><A NAME="tex2html136" HREF="node4.html"></A></B><A HREF="node4.html" NAME="tex2html136">Fundamental
geometric structures</A> <B>Up:<A NAME="tex2html132"></A><A NAME="tex2html132"></A><A NAME="tex2html132"></A><A NAME="tex2html132"></A><A NAME="tex2html132"></A><A NAME="tex2html132" HREF="svi2.html"></A><A NAME="tex2html132" HREF="svi2.html"></A><A NAME="tex2html132" HREF="svi2.html"></A><A NAME="tex2html132" HREF="svi2.html"></A></B><A HREF="svi2.html" NAME="tex2html132">SvLis
Introduction</A> <B>Previous:<A NAME="tex2html126"></A><A NAME="tex2html126"></A><A NAME="tex2html126"></A><A NAME="tex2html126"></A><A NAME="tex2html126"></A><A NAME="tex2html126" HREF="node2.html"></A><A NAME="tex2html126" HREF="node2.html"></A><A NAME="tex2html126" HREF="node2.html"></A><A NAME="tex2html126" HREF="node2.html"></A></B><A HREF="node2.html" NAME="tex2html126">Acknowledgements</A><!--End of Navigation Panel-->
<P><I>Adrian Bowyer</I>
<BR>
<HR>
<BR>&nbsp;
<P><BR>
<CENTER>
<P><IMG SRC="motto.gif" ALT="PERFICTA  PERFRACTA  QVAERENDO  PERFECTA" HEIGHT=25 WIDTH=720></CENTER>

<BR>&nbsp;
<P><BR>
<BR>
<BR>
<BR>
<ADDRESS>

<HR></ADDRESS>

</BODY>
</HTML>
