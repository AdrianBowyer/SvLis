<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="description" content="SvLis User Manual">
   <meta name="keywords" content="svi2">
   <meta name="resource-type" content="document">
   <meta name="distribution" content="global">
   <meta name="GENERATOR" content="Mozilla/4.61 [en] (X11; I; Linux 2.2.12-20 i686) [Netscape]">
   <title>SvLis User Manual</title>
<!--Converted with LaTeX2HTML 97.1 (release) (July 13th, 1997)
 by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippman, Marek Rouchal, Martin Wilck and others -->
<link REL="STYLESHEET" HREF="svi2.css">
<link REL="next" HREF="node10.html">
<link REL="previous" HREF="node8.html">
<link REL="up" HREF="svi2.html">
<link REL="next" HREF="node10.html">
</head>
<body background="svlis_new.gif">

<hr>
<center>
<p><a href="../home.html"><img SRC="svlis.gif" ALT="" BORDER=0 ></a></center>

<center>
<h1>
<b><font size=+4>User Manual</font></b></h1></center>

<center><a href="mailto:svlis@bath.ac.uk">svlis@bath.ac.uk</a>
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<p>Copyright &copy; 1994, 1996, 1999 <a href="http://www.inge.com">Information
Geometers Ltd </a>and <a href="http://www.bath.ac.uk">The University of
Bath</a></center>

<p><br>
<br>
<br>
<p>
<hr>
<p><!--Navigation Panel--><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" HREF="node10.html"></a><a NAME="tex2html232" href="node10.html"></a><a NAME="tex2html232" href="node10.html"></a><a NAME="tex2html232" href="node10.html"></a><a NAME="tex2html232" href="node10.html"></a><a NAME="tex2html232" href="node10.html"></a><a NAME="tex2html232" href="node10.html"></a><a href="node10.html" NAME="tex2html232"><img SRC="next_motif.gif" ALT="next" BORDER=0 height=24 width=37 align=BOTTOM></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" HREF="svi2.html"></a><a NAME="tex2html228" href="svi2.html"></a><a NAME="tex2html228" href="svi2.html"></a><a NAME="tex2html228" href="svi2.html"></a><a NAME="tex2html228" href="svi2.html"></a><a NAME="tex2html228" href="svi2.html"></a><a NAME="tex2html228" href="svi2.html"></a><a href="svi2.html" NAME="tex2html228"><img SRC="up_motif.gif" ALT="up" BORDER=0 height=24 width=26 align=BOTTOM></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" HREF="node8.html"></a><a NAME="tex2html222" href="node8.html"></a><a NAME="tex2html222" href="node8.html"></a><a NAME="tex2html222" href="node8.html"></a><a NAME="tex2html222" href="node8.html"></a><a NAME="tex2html222" href="node8.html"></a><a NAME="tex2html222" href="node8.html"></a><a href="node8.html" NAME="tex2html222"><img SRC="previous_motif.gif" ALT="previous" BORDER=0 height=24 width=63 align=BOTTOM></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" HREF="node1.html"></a><a NAME="tex2html230" href="node1.html"></a><a NAME="tex2html230" href="node1.html"></a><a NAME="tex2html230" href="node1.html"></a><a NAME="tex2html230" href="node1.html"></a><a NAME="tex2html230" href="node1.html"></a><a NAME="tex2html230" href="node1.html"></a><a href="node1.html" NAME="tex2html230"><img SRC="contents_motif.gif" ALT="contents" BORDER=0 height=24 width=65 align=BOTTOM></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" HREF="node11.html"></a><a NAME="tex2html231" href="node11.html"></a><a NAME="tex2html231" href="node11.html"></a><a NAME="tex2html231" href="node11.html"></a><a NAME="tex2html231" href="node11.html"></a><a NAME="tex2html231" href="node11.html"></a><a NAME="tex2html231" href="node11.html"></a><a href="node11.html" NAME="tex2html231"><img SRC="index_motif.gif" ALT="index" BORDER=0 height=24 width=43 align=BOTTOM></a>
<br><b>Next:<a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" HREF="node10.html"></a><a NAME="tex2html233" href="node10.html"></a><a NAME="tex2html233" href="node10.html"></a><a NAME="tex2html233" href="node10.html"></a><a NAME="tex2html233" href="node10.html"></a><a NAME="tex2html233" href="node10.html"></a><a NAME="tex2html233" href="node10.html"></a></b><a href="node10.html" NAME="tex2html233">Bibliography</a><b>Up:<a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" HREF="svi2.html"></a><a NAME="tex2html229" href="svi2.html"></a><a NAME="tex2html229" href="svi2.html"></a><a NAME="tex2html229" href="svi2.html"></a><a NAME="tex2html229" href="svi2.html"></a><a NAME="tex2html229" href="svi2.html"></a><a NAME="tex2html229" href="svi2.html"></a></b><a href="svi2.html" NAME="tex2html229">SvLis
Introduction</a><b>Previous:<a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" HREF="node8.html"></a><a NAME="tex2html223" href="node8.html"></a><a NAME="tex2html223" href="node8.html"></a><a NAME="tex2html223" href="node8.html"></a><a NAME="tex2html223" href="node8.html"></a><a NAME="tex2html223" href="node8.html"></a><a NAME="tex2html223" href="node8.html"></a></b><a href="node8.html" NAME="tex2html223">Afterword</a>
<p><!--End of Navigation Panel--><!--Table of Child-Links--><a NAME="CHILD_LINKS"></a><b>Subsections</b>
<ul>
<li>
<a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" HREF="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" href="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" href="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" href="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" href="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" href="node9.html#SECTION00910000000000000000"></a><a NAME="tex2html234" href="node9.html#SECTION00910000000000000000"></a><a href="node9.html#SECTION00910000000000000000" NAME="tex2html234">Introduction</a></li>

<li>
<a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" HREF="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" href="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" href="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" href="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" href="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" href="node9.html#SECTION00920000000000000000"></a><a NAME="tex2html235" href="node9.html#SECTION00920000000000000000"></a><a href="node9.html#SECTION00920000000000000000" NAME="tex2html235">Errors</a></li>

<li>
<a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" HREF="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" href="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" href="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" href="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" href="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" href="node9.html#SECTION00930000000000000000"></a><a NAME="tex2html236" href="node9.html#SECTION00930000000000000000"></a><a href="node9.html#SECTION00930000000000000000" NAME="tex2html236">Classes
and functions</a></li>

<ul>
<li>
<a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" HREF="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" href="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" href="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" href="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" href="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" href="node9.html#SECTION00931000000000000000"></a><a NAME="tex2html237" href="node9.html#SECTION00931000000000000000"></a><a href="node9.html#SECTION00931000000000000000" NAME="tex2html237">Sums</a></li>

<li>
<a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" HREF="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" href="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" href="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" href="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" href="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" href="node9.html#SECTION00932000000000000000"></a><a NAME="tex2html238" href="node9.html#SECTION00932000000000000000"></a><a href="node9.html#SECTION00932000000000000000" NAME="tex2html238">Geometry</a></li>

<ul>
<li>
<a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" HREF="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" href="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" href="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" href="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" href="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" href="node9.html#SECTION00932100000000000000"></a><a NAME="tex2html239" href="node9.html#SECTION00932100000000000000"></a><a href="node9.html#SECTION00932100000000000000" NAME="tex2html239">The
<tt>sv_point</tt>
struct</a></li>

<li>
<a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" HREF="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" href="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" href="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" href="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" href="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" href="node9.html#SECTION00932200000000000000"></a><a NAME="tex2html240" href="node9.html#SECTION00932200000000000000"></a><a href="node9.html#SECTION00932200000000000000" NAME="tex2html240">The
<tt>sv_line</tt>
struct</a></li>

<li>
<a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" HREF="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" href="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" href="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" href="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" href="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" href="node9.html#SECTION00932300000000000000"></a><a NAME="tex2html241" href="node9.html#SECTION00932300000000000000"></a><a href="node9.html#SECTION00932300000000000000" NAME="tex2html241">The
<tt>sv_plane</tt>
struct</a></li>
</ul>

<li>
<a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" HREF="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" href="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" href="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" href="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" href="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" href="node9.html#SECTION00933000000000000000"></a><a NAME="tex2html242" href="node9.html#SECTION00933000000000000000"></a><a href="node9.html#SECTION00933000000000000000" NAME="tex2html242">The
<tt>sv_interval</tt>
and <tt>sv_box</tt> structs</a></li>

<li>
<a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" HREF="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" href="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" href="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" href="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" href="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" href="node9.html#SECTION00934000000000000000"></a><a NAME="tex2html243" href="node9.html#SECTION00934000000000000000"></a><a href="node9.html#SECTION00934000000000000000" NAME="tex2html243">The
<tt>sv_primitive</tt>
class</a></li>

<li>
<a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" HREF="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" href="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" href="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" href="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" href="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" href="node9.html#SECTION00935000000000000000"></a><a NAME="tex2html244" href="node9.html#SECTION00935000000000000000"></a><a href="node9.html#SECTION00935000000000000000" NAME="tex2html244">The
<tt>sv_set</tt>
class</a></li>

<li>
<a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" HREF="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" href="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" href="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" href="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" href="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" href="node9.html#SECTION00936000000000000000"></a><a NAME="tex2html245" href="node9.html#SECTION00936000000000000000"></a><a href="node9.html#SECTION00936000000000000000" NAME="tex2html245">The
<tt>sv_attribute</tt>
class</a></li>

<li>
<a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" HREF="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" href="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" href="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" href="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" href="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" href="node9.html#SECTION009312000000000000000"></a><a NAME="tex2html251" href="node9.html#SECTION009312000000000000000"></a><a href="node9.html#SECTION009312000000000000000" NAME="tex2html251">The
<tt>sv_set_list</tt>
class</a></li>

<li>
<a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" HREF="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" href="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" href="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" href="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" href="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" href="node9.html#SECTION009313000000000000000"></a><a NAME="tex2html252" href="node9.html#SECTION009313000000000000000"></a><a href="node9.html#SECTION009313000000000000000" NAME="tex2html252">The
<tt>sv_model</tt>
class</a></li>

<li>
<a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" HREF="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" href="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" href="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" href="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" href="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" href="node9.html#SECTION00937000000000000000"></a><a NAME="tex2html246" href="node9.html#SECTION00937000000000000000"></a><a href="node9.html#SECTION00937000000000000000" NAME="tex2html246">The
<tt>sv_surface</tt>
class</a></li>

<li>
<a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" HREF="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" href="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" href="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" href="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" href="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" href="node9.html#SECTION00938000000000000000"></a><a NAME="tex2html247" href="node9.html#SECTION00938000000000000000"></a><a href="node9.html#SECTION00938000000000000000" NAME="tex2html247">The
<tt>sv_view</tt>
class</a></li>

<li>
<a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" HREF="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" href="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" href="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" href="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" href="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" href="node9.html#SECTION00939000000000000000"></a><a NAME="tex2html248" href="node9.html#SECTION00939000000000000000"></a><a href="node9.html#SECTION00939000000000000000" NAME="tex2html248">The
<tt>sv_lightsource</tt>
and <tt>sv_light_list classes</tt></a></li>

<li>
<a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" HREF="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" href="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" href="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" href="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" href="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" href="node9.html#SECTION009310000000000000000"></a><a NAME="tex2html249" href="node9.html#SECTION009310000000000000000"></a><a href="node9.html#SECTION009310000000000000000" NAME="tex2html249">The
<tt>sv_picture</tt>
class</a></li>

<li>
<a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" HREF="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" href="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" href="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" href="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" href="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" href="node9.html#SECTION009311000000000000000"></a><a NAME="tex2html250" href="node9.html#SECTION009311000000000000000"></a><a href="node9.html#SECTION009311000000000000000" NAME="tex2html250">The
<tt>sv_p_gon</tt>
struct</a></li>

<li>
<a href="#ab300">Voronoi diagrams</a></li>
</ul>

<li>
<a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" HREF="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" href="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" href="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" href="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" href="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" href="node9.html#SECTION00940000000000000000"></a><a NAME="tex2html253" href="node9.html#SECTION00940000000000000000"></a><a href="node9.html#SECTION00940000000000000000" NAME="tex2html253">Utilities</a></li>

<li>
<a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" HREF="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" href="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" href="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" href="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" href="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" href="node9.html#SECTION00950000000000000000"></a><a NAME="tex2html254" href="node9.html#SECTION00950000000000000000"></a><a href="node9.html#SECTION00950000000000000000" NAME="tex2html254">SvLis
programs</a></li>
</ul>
<!--End of Table of Child-Links-->
<hr>
<h1>
<a NAME="SECTION00900000000000000000"></a><b><font size=+4>SvLis User Manual</font></b></h1>

<h1>
<a NAME="MANUAL"></a><a NAME="SECTION00910000000000000000"></a>Introduction</h1>
This manual contains a description of all of svLis's procedures, functions,
and operators. It is intended as a stand-alone description for reference
by those already familiar with svLis, either through having read this <a href="node1.html">book
</a>on
it or through having used the software, or both.
<p>SvLis is a set-theoretic geometric modeller written in C<font size=-1>++</font>
that uses object-orientation and operator and function overloading to allow
geometric computing to be done efficiently.
<p><a NAME="2672"></a><a NAME="2673"></a><a NAME="4541"></a><a NAME="4542"></a><a NAME="2680"></a><a NAME="2681"></a><a NAME="2683"></a><a NAME="2684"></a>On
the question of operators, I use&nbsp;<img SRC="img5.gif" ALT="$ \wedge $" BORDER=0 height=12 width=10 align=BOTTOM>&nbsp;
for a few things (e.g. exponentiation, symmetric difference) that usually
bind quite tightly under normal arithmetical rules. The&nbsp;<img SRC="img5.gif" ALT="$ \wedge $" BORDER=0 height=12 width=10 align=BOTTOM>
(<font size=-1>XOR</font>) operator has pretty low precedence in C/C++
(lower than <tt>+</tt>, for example). As C<font size=-1>++</font> doesn't
allow one to change operator precedence, you <i>have</i> to use brackets.
<p><a NAME="4543"></a><a NAME="4544"></a><a NAME="2688"></a>Before calling
any other svLis procedures, you must call the function
<blockquote><tt>void svlis_init()</tt></blockquote>
to get things started.&nbsp;&nbsp; There is a corresponding&nbsp; <tt>int
svlis_end(int i)</tt>&nbsp; function that copies its argument to its return
value, so the broad pattern of a svLis program is:
<br>&nbsp;
<blockquote><tt>#include "svlis.h"</tt>
<p><tt>int main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; svlis_init();</tt>
<p><tt>// ... Do some work with svLis ...</tt>
<p><tt>// An error exit:</tt>
<p><tt>&nbsp;&nbsp;&nbsp; if(things_have_gone_horribly_wrong()) return(svlis_end(1));
// Or any non-0 value</tt>
<p><tt>// A successful exit:</tt>
<p><tt>&nbsp;&nbsp;&nbsp; return(svlis_end(0));</tt>
<br><tt>}</tt></blockquote>

<p><br>The files mentioned in the descriptions below reside in three sub-directories
beneath whichever directory svLis is installed in on your system.&nbsp;
The directory <tt>include </tt>contains the<tt> .h </tt>files, and the
directory <tt>sv_user </tt>contains user-modifiable C++ source code (which
always, in svLis has the extension <tt>.cxx</tt>).&nbsp; If you have a
<a href="../licence.html">source-code
licence,</a> other source code resides in the directory <tt>.src</tt>,
otherwise these files will not be available to you and will only exist
in compiled form in a library.&nbsp; Files that are always available are
in <font color="#FF0000">red</font> in what follows.
<p>In all the descriptions below, the arguments of functions<a NAME="2689"></a><a NAME="2690"></a>&nbsp;
are, of course, given their types--for example
<blockquote><tt>plane_line(sv_plane f, sv_line l)</tt>.</blockquote>
In almost all cases the actual functions acquire their arguments by reference:
<blockquote><tt>plane_line(const sv_plane&amp; f, const sv_line&amp; l)</tt></blockquote>
This is more efficient for classes and structures (it saves a lot of copying),
but would make this documentation cumbersome to read (and to write...)
so it has been left out here; if you really need to know, look at the appropriate
<tt>.h</tt>
files.
<p>In almost all cases, the member functions of svLis classes leave the
parent object unaffected--they are <tt>const</tt> functions--and return
a new object which is the result of applying the function to the parent
object. Thus one often writes code like:
<blockquote>
<pre>sv_model ma, mb;

// ...

mb = ma.facet();</pre>
</blockquote>
in order to retain the original object (<tt>ma</tt>) and to generate a
new one (<tt>mb</tt>). However, it is equally common to write
<blockquote><tt>ma = ma.facet()</tt>;</blockquote>
which overwrites the original. SvLis's internal memory management makes
such overwriting very efficient.
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<h1>
<a NAME="SECTION00920000000000000000"></a><a NAME="SVERR"></a><a NAME="4545"></a><a NAME="4546"></a><a NAME="2703"></a>Errors</h1>
Whenever svLis detects an error it calls an error-handling procedure:
<blockquote><tt>void svlis_error(char* p, char* mess, sv_err level)</tt></blockquote>
This procedure is user-modifiable (it is in the file
<tt><font color="#FF0000">sve.cxx<a NAME="4547"></a><a NAME="4548"></a></font></tt>),
so you can write your own error handler if you want. The string <tt>p</tt>
is the name of the procedure in which the error occurred, the string <tt>mess</tt>
is a message that describes the mess, and <tt>level</tt> is an indication
of severity. The severities are (in increasing magnitude of catastrophe):
<blockquote><tt>SV_DEBUG,</tt>
<br><tt>SV_COMMENT,</tt>
<br><tt>SV_WARNING,</tt>
<br><tt>SV_FATAL, </tt>and
<br><tt>SV_CORRUPT</tt></blockquote>
As <tt>svlis_error</tt> is supplied, it allows you to call the procedure
<blockquote><a NAME="4549"></a><a NAME="4550"></a><a NAME="2716"></a><tt>set_sv_e_lev(sv_err
l)</tt></blockquote>
with one of these severities as its argument; errors below the level that
you set will not be reported; the default level at which you start to hear
about things is <tt>SV_WARNING</tt>.
<p>Now matter how severe the error is that has occurred, the as-supplied
<tt>svlis_error</tt>
always returns. If you want you can change this, but svLis generally takes
the view that users should be allowed to go to hell in their own way, as
long as svLis points out what road they're on; so such a change would be
rather at odds with the rest of the software.
<p>There are a lot of occasions in svLis when you can attempt operations
which <i>may</i> fail (such as trying to find the line of intersection
between two parallel planes, for example) but which are not errors. The
function you have called will always return (if your actual data are dud,
such as when one of the planes has a zero-length normal vector, <tt>svlis_error</tt>
will be called first) but a flag<a NAME="2721"></a>&nbsp; value will be
recorded. You can get at this by calling
<blockquote><a NAME="4551"></a><a NAME="4552"></a><tt>sv_err get_svlis_flag()</tt></blockquote>
This returns a <tt>flag_val</tt> (which is defined in <tt><font color="#FF0000">enum_def.h<a NAME="4553"></a><a NAME="4554"></a></font></tt>).
If your calculation worked as planned, you get <tt>0</tt> back; if something
went wrong you get a value indicating what the trouble was. So you should
write code like:
<blockquote>
<pre>flag_val dud;
// ....
x = chancy_function(my_data);
if ( dud = get_svlis_flag() )
{
&nbsp; cerr &lt;&lt; "Hmmm.&nbsp; That didn't work." &lt;&lt; "Flag was: " &lt;&lt; dud &lt;&lt; '\n';
&nbsp; // ....
} else
{
&nbsp; // ....
}</pre>
</blockquote>
<font size=+0>Some functions return the flag value as an argument too (see
below), but the value is always recorded for get_svlis_flag() as well.</font>
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<h1>
<a NAME="SECTION00930000000000000000"></a><a NAME="CLASSFUN"></a>Classes
and functions</h1>
This describes each svLis <tt>class</tt> (or <tt>struct</tt>) and its associated
functions and operators. It is divided up in much the same way as the source-code
files; see the header (<tt>.h</tt>) files for less transparent but more
complete explanations.
<p>If you can't be bothered to figure out which <tt>.h</tt> files to include,
then include <tt><font color="#FF0000">svlis.h</font></tt>, which pulls
them all in.
<p>All the svLis structs and classes have the <tt>&lt;&lt;<a NAME="4555"></a><a NAME="4556"></a></tt>&nbsp;
and <tt>>><a NAME="4557"></a><a NAME="4558"></a></tt>&nbsp; operators defined
for output and input to
<tt>ostream</tt>s<a NAME="4559"></a><a NAME="4560"></a>&nbsp;
and
<tt>istream</tt>s<a NAME="4561"></a><a NAME="4562"></a>. These are
not primarily intended to produce user-readable output, but output in a
form that can be read back in and checked by svLis. However, if you call
the procedure
<blockquote><a NAME="4563"></a><a NAME="4564"></a><tt>void pretty_print(1)</tt></blockquote>
output will then be indented, and is reasonably easy to interpret. Calling
<blockquote><tt>pretty_print(0)</tt></blockquote>
turns off indented output (this is the default state), which makes the
output less legible but about 30% more compact. SvLis can read in both
indented and unindented files, of course. Even unindented files aren't
all that compact--that's why we have programs like <tt>gzip</tt> and <tt>winzip</tt>--though
even uncompressed they are much more compact than a boundary-representation
data file.
<p>Some of the data structures that svLis creates are very complicated.
All of this complexity is retained across <i>a single write or read</i>.
However, if you write out two things separately that were related, then
that relationship will be lost when they are separately read back in. A
good general rule is to write out the highest-level structure that incorporates
everything you want.
<br>&nbsp;
<br>&nbsp;
<h2>
<a NAME="SECTION00931000000000000000"></a><a NAME="4565"></a><a NAME="4566"></a><a NAME="4567"></a><a NAME="4568"></a><a NAME="4569"></a><a NAME="4570"></a><a NAME="SUMS2"></a>Sums</h2>
<i>Files:</i> <tt><font color="#FF0000">sums.h, enum_def.h</font>, sums.cxx</tt>
<br>&nbsp;
<p>These macros, functions and procedures implement constant definitions
and some simple arithmetical operations.
<p>Types <tt>sv_real</tt> and <tt>sv_integer</tt> are <tt>#define</tt>d
to be
<tt>float</tt> and <tt>long</tt>, and are used in almost all<a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" HREF="footnode.html#4571"></a><a NAME="tex2html26" href="footnode.html#4571"></a><a NAME="tex2html26" href="footnode.html#4571"></a><a NAME="tex2html26" href="footnode.html#4571"></a><a NAME="tex2html26" href="footnode.html#4571"></a><a NAME="tex2html26" href="footnode.html#4571"></a><a NAME="tex2html26" href="footnode.html#4571"></a><a href="footnode.html#4571" NAME="tex2html26"><img SRC="foot_motif.gif" ALT="[*]" BORDER=1 height=10 width=10 align=BOTTOM></a>
svLis declarations. This makes it easier to switch to <tt>double</tt> or
<tt>int</tt>
should the need arise.&nbsp; Here are the functions <tt>sums</tt> defines:
<br>&nbsp;
<dl>
<dl>
<dt>
<a NAME="IR"></a><a NAME="4572"></a><a NAME="4573"></a><b><tt>sv_integer
round(sv_real a)</tt></b></dt>

<dd>
returns the nearest integer to a.</dd>

<dt>
<a NAME="4576"></a><a NAME="4577"></a><b><tt>sv_real max(sv_real a, sv_real
b)</tt></b></dt>

<br><b><tt>sv_integer max(sv_integer a, sv_integer b)</tt></b>
<dl>return the maximum of two numbers.&nbsp; Rather tiresomely the Microsoft
Visual C++ compiler reserves the words <tt>max</tt> and <tt>min</tt> (even
though this is not really legitimate).&nbsp; On Microsoft implementations
svLis gets round this by the following rather nasty code:
<br>&nbsp;
<dl><tt>#ifdef SV_MSOFT</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define max maxx</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define min minn</tt>
<br><tt>#endif</tt></dl>
so beware....&nbsp; Other svLis implementations don't suffer this, of course.</dl>

<dt>
<a NAME="4578"></a><a NAME="4579"></a><b><tt>sv_real min(sv_real a, sv_real
b)</tt></b></dt>

<br><b><tt>sv_integer min(sv_integer a, sv_integer b)</tt></b>
<dl>return the minimum of two numbers a and b.</dl>

<dt>
<a NAME="ab4"></a><b><tt>sv_real sign(sv_real a)</tt></b></dt>

<dd>
returns 1 or -1 depending on the sign of a.&nbsp; 0 gives -1.</dd>

<dt>
<a NAME="4580"></a><a NAME="4581"></a><b><tt>sv_real pow(sv_real a, sv_integer
b)</tt></b></dt>

<dd>
returns <tt>a<sup>b</sup></tt>. The variable <tt>b </tt>must be non-negative.</dd>

<dt>
<a NAME="4582"></a><a NAME="4583"></a><b><tt>sv_real s_sqrt(sv_real a)</tt></b></dt>

<dd>
returns the square root of the absolute value of a, with the sign of a
applied; a signed square root.</dd>

<dt>
<a NAME="4584"></a><a NAME="4585"></a><a NAME="4586"></a><b><tt>prim_op
same(sv_real a, sv_real b)</tt></b></dt>

<dd>
SvLis uses the
<tt>==</tt> operator to mean identical, and
<tt>!=</tt>
to mean different, even in some tiny way; the two are logical operators.
Of course, <tt>a == b</tt> is almost always meaningless if <tt>a </tt>and
<tt>b</tt>
are
<tt>sv_reals</tt>, so svLis also provides an overloaded series of <tt>same
</tt>functions
to compare items containing real numbers. The same of two reals can return
three values (see the section on <tt>sv_primitive</tt>s on page&nbsp;<a href="node9.html#SVPRIM2"><img SRC="cross_ref_motif.gif" ALT="[*]" BORDER=1 height=10 width=10 align=BOTTOM></a>):
<tt>SV_ZERO
</tt>means
the numbers are different within a tolerance (<tt>SV_ZERO</tt> is actually
0, and so will evaluate as false in <tt>if</tt> statements and the like);
<tt>SV_PLUS</tt>
means they are the same within the tolerance; and <tt>SV_COMP
</tt>means
that <tt>a = -b</tt> within the tolerance.</dd>

<dt>
<a NAME="4587"></a><a NAME="4588"></a><b><tt>void set_same_tol(sv_real
a)</tt></b></dt>

<dd>
sets the tolerance of the <tt>same</tt> functions to <tt>a</tt>.</dd>

<dt>
<a NAME="4589"></a><a NAME="4590"></a><b><tt>sv_real get_same_tol()</tt></b></dt>

<dd>
returns the tolerance of the <tt>same</tt> functions.</dd>

<dt>
<a NAME="4591"></a><a NAME="4592"></a><b><tt>void set_seed(sv_integer s)</tt></b></dt>

<dd>
seeds the random number generator with <tt>s</tt>.</dd>

<dt>
<a NAME="4593"></a><a NAME="4594"></a><b><tt>sv_integer ran_int()</tt></b></dt>

<dd>
returns a random integer between
<tt>0</tt> and<tt> 0x7fffffff.</tt></dd>

<dt>
<a NAME="4595"></a><a NAME="4596"></a><b><tt>sv_real ran_real()</tt></b></dt>

<dd>
returns a random real in <tt>[0.0, 1.0]</tt>.</dd>

<dt>
<a NAME="4597"></a><a NAME="4598"></a><a NAME="2841"></a><b><tt>sv_integer
get_svlis_version()</tt></b></dt>

<dd>
returns the version number of the svLis library that you are using.</dd>

<br>&nbsp;</dl>

<p><br>The files <tt><font color="#FF0000">sums.h</font></tt> and <tt>sums.cxx
</tt>also
contain a number of functions that svLis uses internally for input and
output.All the global constants that svLis uses are defined in <tt><font color="#FF0000">sums.h</font></tt>
and <tt><font color="#FF0000">enum_def.h</font>.</tt> You can cause all
sorts of entertaining errors by changing their values.
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<h2>
<a NAME="SECTION00932000000000000000"></a><a NAME="4599"></a><a NAME="4600"></a><a NAME="4601"></a><a NAME="4602"></a><a NAME="SIMPG"></a>Geometry</h2>
<i>Files:</i> <tt><font color="#FF0000">geometry.h</font>, geometry.cxx</tt>
<br>&nbsp;
<p>As the names imply, this lot does geometry.
<br>&nbsp;
<h3>
<a NAME="SECTION00932100000000000000"></a><a NAME="4604"></a><a NAME="4605"></a><a NAME="4606"></a><a NAME="4607"></a>The
<tt>sv_point</tt>
struct</h3>
The statement
<blockquote>
<pre><a NAME="4608"></a><a NAME="4609"></a>sv_point p = sv_point(sv_real xc, sv_real yc, sv_real zc);</pre>
</blockquote>
makes a point (<i>i.e.</i> a vector) from three coordinate values. The
data are
<tt>p.x, p.y,</tt> and <tt>p.z</tt>. The null constructor (<i>i.e.
</i>what
you get when you declare <tt>sv_point q;</tt> in your program) gives the
point (0, 0, 0). Point operators are:
<br>&nbsp;
<dl>
<dt>
-</dt>

<dd>
<a NAME="4610"></a><a NAME="4611"></a><a NAME="4612"></a>(monadic) negate
coordinates.</dd>

<dt>
+</dt>

<dd>
<a NAME="4613"></a><a NAME="4614"></a>vector addition<a NAME="2868"></a><a NAME="2869"></a>.</dd>

<dt>
-</dt>

<dd>
<a NAME="4615"></a>(diadic) vector subtraction<a NAME="2871"></a><a NAME="2872"></a>.</dd>

<dt>
*</dt>

<dd>
<a NAME="4616"></a><a NAME="4617"></a>&nbsp; or /<a NAME="4618"></a><a NAME="4619"></a>&nbsp;
with an <tt>sv_real </tt>scales the point<a NAME="2879"></a><a NAME="2880"></a>.</dd>

<dt>
*</dt>

<dd>
scalar product<a NAME="2881"></a><a NAME="2882"></a>.</dd>

<dt>
<img SRC="img5.gif" ALT="$ \wedge $" BORDER=0 height=12 width=10 align=BOTTOM></dt>

<dd>
<a NAME="4620"></a><a NAME="4621"></a>vector product<a NAME="2885"></a><a NAME="2886"></a>.</dd>

<dl>
<dd>
</dd>
</dl>
</dl>
And the point member and other functions are:
<br>&nbsp;
<dl>
<dt>
<a NAME="4622"></a><a NAME="4623"></a><a NAME="4624"></a><a NAME="4625"></a><b><tt>sv_real
sv_point::mod()</tt></b></dt>

<dd>
returns the modulus<a NAME="2893"></a><a NAME="2894"></a> (<i>i.e. </i>the
length).</dd>

<dt>
<a NAME="4626"></a><a NAME="4627"></a><a NAME="4628"></a><a NAME="4629"></a><b><tt>sv_point
sv_point::norm()</tt></b></dt>

<dd>
returns a normalized (unit length) point in the same direction as the original<a NAME="2899"></a><a NAME="2900"></a>.</dd>

<dt>
<a NAME="4630"></a><a NAME="4631"></a><b><tt>sv_point sv_point::spin(sv_line
l, sv_real a)</tt></b></dt>

<dd>
rotates<a NAME="2903"></a><a NAME="2904"></a>&nbsp; the point round the
line. The argument <tt>a</tt> is the angle in radians (clockwise looking
along the line's direction vector).</dd>

<dt>
<a NAME="4632"></a><a NAME="4633"></a><b><tt>sv_point sv_point::mirror(sv_plane
m)</tt></b></dt>

<dd>
returns the mirror<a NAME="2908"></a><a NAME="2909"></a>&nbsp; image of
the point in m.</dd>

<dt>
<a NAME="4634"></a><a NAME="4635"></a><b><tt>sv_point sv_point::scale(sv_point
c, sv_real s)</tt></b></dt>

<dd>
scales the point<a NAME="2913"></a><a NAME="2914"></a>&nbsp; away/towards
the point <tt>c </tt>by factor <tt>s.</tt></dd>

<dt>
<b><tt>sv_point sv_point::scale(sv_line axis, sv_real s)</tt></b></dt>

<dl>
<dt>
scales the point along the axis (in 1 dimension) from the origin of axisby
factor <tt>s.</tt></dt>
</dl>

<dt>
<a NAME="4636"></a><a NAME="4637"></a><b><tt>sv_real dist_2(sv_point a,
sv_point b)</tt></b></dt>

<dd>
returns the squared distance between the two points.</dd>

<dt>
<a NAME="4638"></a><a NAME="4639"></a><b><tt>sv_integer sv_point::tag()</tt></b></dt>

<dd>
returns the unique svLis tag<a NAME="2921"></a><a NAME="2922"></a>&nbsp;
for points.</dd>

<dt>
<a NAME="4640"></a><a NAME="4641"></a><a NAME="2925"></a><a NAME="2926"></a><b><tt>prim_op
same(sv_point a, sv_point b)</tt></b></dt>

<dd>
returns SV_ZERO, SV_PLUS or SV_COMP as for <a href="#4584">sv_reals.</a></dd>

<dt>
<a NAME="9101"></a><b><tt>sv_point right(sv_point a)</tt></b></dt>

<dd>
generates an arbitrary unit-length point at right-angles to the argument
point.</dd>

<dt>
<a NAME="9102"></a><b><tt>void sv_axes(const sv_point&amp; p, sv_point&amp;
u, sv_point&amp; v, sv_point&amp; w)</tt></b></dt>

<dd>
generates three points. The point <tt>w</tt> is
<tt>p</tt> normailzed,
and <tt>u </tt>and <tt>v </tt>form unit-length mutually perpendicular right-handed
coordinate axes with it.</dd>

<dd>
</dd>
</dl>

<p><br>SvLis makes no distinction between a point being used as a relative
position or offset, and one that is being used to specify the absolute
coordinates of something. This is entirely decided by context.
<p>The include file <tt><font color="#FF0000">enum_def.h</font></tt> contains
<tt>#define</tt>s
for five <tt>sv_point</tt>s:&nbsp;<a NAME="ab5"></a><tt>SV_X, SV_Y, SV_Z,SV_OO,
and SV_DIAG</tt> which are the three unit vectors in the coordinate directions,
the origin, and the point (1,1,1) respectively. These are useful in constructing
lots of different geometric objects, and are provided simply to save typing.
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<h3>
<a NAME="SECTION00932200000000000000"></a><a NAME="4643"></a><a NAME="4644"></a><a NAME="SVLINE2"></a>The
<tt>sv_line</tt>
struct</h3>
The statement
<blockquote><tt>sv_line l = line(sv_point d, sv_point org);</tt></blockquote>
creates a parametric line<a NAME="2942"></a>&nbsp; through the point <tt>org<a NAME="4646"></a></tt>&nbsp;
in the direction
<tt>d</tt> (<tt>d</tt> need not be normalized; it is normalized
internally, though). The data are <tt>l.direction</tt> and <tt>l.origin</tt>.
In case you can't be bothered to define a line when you declare it, you
should know that the default line is the <i>z</i> axis. Operators and functions
acting on lines are:
<br>&nbsp;
<dl>
<dt>
<b><tt>sv_line + sv_point</tt> </b>and</dt>

<dt>
<b><tt>sv_line - sv_point</tt></b></dt>

<dd>
these affect a translation (<i>i.e.</i> origin has the point added).</dd>

<dt>
<a NAME="4647"></a><a NAME="4648"></a><a NAME="2954"></a><a NAME="2955"></a><b><tt>sv_line
sv_line::spin(sv_line l, sv_real a)</tt></b></dt>

<dd>
rotates&nbsp; the line round the line l. The argument a is the angle in
radians (clockwise looking along the line's direction vector).</dd>

<dt>
<a NAME="4649"></a><a NAME="4650"></a><b><tt>sv_line sv_line::mirror(sv_plane
m)</tt></b></dt>

<dd>
returns the mirror<a NAME="2960"></a><a NAME="2961"></a>&nbsp; image of
the line in m.</dd>

<dt>
<a NAME="4651"></a><a NAME="4652"></a><b><tt>sv_line sv_line::scale(sv_point
c, sv_real s)</tt></b></dt>

<dl>
<dt>
scales the line<a NAME="2965"></a><a NAME="2966"></a>&nbsp; away/towards
the point c by factor s.</dt>
</dl>

<dt>
<b><tt>sv_line sv_line::scale(sv_line axis, sv_real s)</tt></b></dt>

<dl>
<dt>
scales the line along <tt>axis </tt>(in 1 dimension) from the origin of
<tt>axis
</tt>by factor <tt>s.</tt></dt>
</dl>

<dt>
<a NAME="4653"></a><a NAME="4654"></a><b><tt>sv_point line::point(sv_real
t)</tt></b></dt>

<dd>
returns the point on the line represented by the parameter value t.</dd>

<dt>
<a NAME="4655"></a><a NAME="4656"></a><a NAME="2974"></a><a NAME="2975"></a><b><tt>prim_op
same(sv_line a, sv_line b)</tt></b></dt>

<dd>
returns SV_ZERO, SV_PLUS or SV_COMP as for <a href="#4584">sv_reals.
</a>The
complement of a line is in the same place, but going in the opposite direction.</dd>

<dt>
<a NAME="4657"></a><a NAME="4658"></a><b><tt>sv_integer sv_line::tag()</tt></b></dt>

<dd>
returns the unique svLis tag<a NAME="2981"></a><a NAME="2982"></a>&nbsp;
for lines.</dd>
</dl>

<p><br>The include file <font color="#FF0000">enum_def<tt>.h</tt></font>
contains <tt>#define</tt>s for three sv_lines:&nbsp;<a NAME="ab6"></a><tt>SV_XL,
SV_YL, and SV_ZL</tt> which are the coordinate axes as lines.
<br>&nbsp;
<dl>&nbsp;</dl>

<h3>
<a NAME="SECTION00932300000000000000"></a><a NAME="4660"></a><a NAME="4661"></a><a NAME="SVPLANE2"></a>The
<tt>sv_plane</tt>
struct</h3>
The statement
<blockquote><tt>sv_plane f = sv_plane(sv_point n, sv_point org);</tt></blockquote>
creates a plane passing through <tt>org</tt> with normal <tt>n</tt> (the
normal doesn't need to be unit length, though it will be made so internally).
The plane is
<br>&nbsp;
<blockquote><tt>f.normal.x</tt><i> * X + </i><tt>f.normal.y</tt><i> * Y
+ </i><tt>f.normal.z</tt><i> * Z + </i><tt>f.d</tt><i> = 0.</i></blockquote>
The null constructor gives the (<i>x</i>,
<i>y</i>) plane. When you know
the coefficients, there is a constructor
<br>&nbsp;
<blockquote><tt>sv_plane p = sv_plane(sv_real a, sv_real b, sv_real c,
sv_real d);</tt></blockquote>
which builds a plane--it will be normalized, even if your coefficients
weren't. There is also a constructor
<br>&nbsp;
<blockquote><tt>sv_plane p = sv_plane(sv_point n, sv_real d);</tt></blockquote>
which builds a plane from its normal vector and the constant term in the
plane's equation--again the plane will be normalized, even if your arguments
weren't. Finally, there is a constructor
<br>&nbsp;
<blockquote><tt>sv_plane p = sv_plane(sv_point a, sv_point b, sv_point
c);</tt></blockquote>
which builds a plane from three points lying in it (obviously these mustn't
be colinear). Plane operators<a NAME="MANPLANE"></a>&nbsp; and functions
are:
<br>&nbsp;
<dl>
<dt>
<a NAME="4662"></a><a NAME="4663"></a><a NAME="4664"></a><b><tt><font size=+1>-</font></tt></b></dt>

<dd>
(monadic) gives the plane's<a NAME="3001"></a><a NAME="3002"></a>&nbsp;
complement (i.e. multiply all coefficients by -1).</dd>

<dt>
<a NAME="4665"></a><a NAME="4666"></a><a NAME="3005"></a><a NAME="3006"></a><b><tt>sv_plane
+ sv_point</tt></b></dt>

<dd>
effects a translation.</dd>

<dt>
<a NAME="3007"></a><b><tt>sv_plane - sv_point</tt></b></dt>

<dd>
diadic minus operator; effects a translation in the opposite sense.</dd>

<dt>
<a NAME="4667"></a><a NAME="4668"></a><a NAME="3011"></a><a NAME="3012"></a><b><tt>sv_real
sv_plane::value(sv_point p)</tt></b></dt>

<dd>
returns the signed distance of the point from the plane.</dd>

<dt>
<a NAME="4669"></a><a NAME="4670"></a><a NAME="3015"></a><a NAME="3016"></a><b><tt>sv_plane
sv_plane::spin(sv_line l, sv_real a)</tt></b></dt>

<dd>
rotates&nbsp; the plane round the line. The argument <tt>a</tt> is the
angle in radians (clockwise looking along the line's direction vector).</dd>

<dt>
<a NAME="4671"></a><a NAME="4672"></a><a NAME="3020"></a><a NAME="3021"></a><b><tt>sv_plane
sv_plane::mirror(sv_plane m)</tt></b></dt>

<dd>
returns the mirror&nbsp; image of the plane in m.</dd>

<dt>
<a NAME="4673"></a><a NAME="4674"></a><a NAME="3025"></a><a NAME="3026"></a><b><tt>sv_plane
sv_plane::scale(sv_point c, sv_real s)</tt></b></dt>

<dd>
scales the plane&nbsp; away/towards the point c by factor s.</dd>

<dt>
<b><tt>sv_plane sv_plane::scale(sv_line axis, sv_real s)</tt></b></dt>

<dl>
<dt>
scales the plane in 1 dimension along the line <tt>axis</tt> from its origin
by factor s.&nbsp; The potential function of the plane is not changed (i.e.
the plane equation stays normalized).&nbsp; See also <a href="#ab6565">the
<tt>scale</tt>
function for primitives</a>.</dt>
</dl>

<dt>
<a NAME="4675"></a><a NAME="4676"></a><b><tt>sv_line planes_line(sv_plane
f, sv_plane g, flag_val &amp;flag)</tt></b></dt>

<dd>
returns the line of intersection between two planes. The origin of the
line will be the point on it nearest the origin of coordinates. If the
planes are parallel,
<tt>flag </tt>will return a value of NO_CROSS after
the call. I managed to resist the temptation to use overloading to make
this function sv_plane &amp; sv_plane....</dd>

<dt>
<a NAME="4677"></a><a NAME="4678"></a><b><tt>sv_real plane_line_t(sv_plane
f, sv_line l, flag_val &amp;flag)</tt></b></dt>

<dd>
returns the value of the line's parameter where the line crosses the plane.
If it doesn't cross, <tt>flag<a NAME="4679"></a><a NAME="4680"></a></tt>
will tell you.</dd>

<dt>
<a NAME="4681"></a><a NAME="4682"></a><b><tt>sv_point plane::point(sv_line
l)</tt></b></dt>

<dd>
puts the answer from
<tt>plane_line_t
</tt>into
<tt><a href="#4653">line::point(...).</a></tt></dd>

<dt>
<a NAME="4683"></a><a NAME="4684"></a><b><tt>sv_point planes_point(sv_plane
f, sv_plane g, sv_plane h, flag_val &amp;flag)</tt></b></dt>

<dl>
<dt>
returns the point where three planes intersect.&nbsp;&nbsp; <tt>flag </tt>tells
tales as usual.</dt>
</dl>

<dt>
<a NAME="4685"></a><a NAME="4686"></a><a NAME="3049"></a><a NAME="3050"></a><b><tt>prim_op
same(sv_plane a, sv_plane b)</tt></b></dt>

<dd>
returns SV_ZERO, SV_PLUS or SV_COMP as for <tt><a href="#4584">sv_reals.</a></tt>
The complement of a plane is in the same place, but has the opposite normal
vector.</dd>

<dt>
<a NAME="4687"></a><a NAME="4688"></a><a NAME="3056"></a><a NAME="3057"></a><b><tt>sv_integer
sv_plane::tag()</tt></b></dt>

<dd>
returns the unique svLis tag&nbsp; for planes.</dd>
</dl>

<dd>
See also the <b><tt><a href="#4748">sv_plane::range(sv_box b)</a> </tt></b>function.</dd>

<dl>
<dl>&nbsp;</dl>
</dl>
</dl>
The include file <tt><font color="#FF0000">enum_def.h</font></tt> contains
<tt>#define</tt>s
for three
<tt>sv_planes:<a NAME="ab7"></a>SV_XP, SV_YP, and SV_ZP</tt>&nbsp;
which are the <i>(y, z), (x, z) </i>and <i>(x, y)</i> planes respectively.
<br>&nbsp;
<dl>&nbsp;
<br>&nbsp;
<h2>
<a NAME="SECTION00933000000000000000"></a><a NAME="4690"></a><a NAME="4691"></a><a NAME="4692"></a><a NAME="4693"></a><a NAME="INTARITH"></a>The
<tt>sv_interval</tt>
and
<tt>sv_box</tt> structs</h2>
<i>Files:</i> <tt><font color="#FF0000">interval.h</font>, interval.cxx</tt>
<br>&nbsp;
<p>SvLis uses interval arithmetic a lot. The <tt>sv_interval</tt> structure
implements this, but interval division is not accommodated (despite division's
involving&nbsp;<img SRC="img13.gif" ALT="$\infty$" BORDER=0 height=10 width=20 align=BOTTOM>,
it is perfectly well-behaved) as svLis does not allow rational <a href="#4761">primitives</a>.
<p>The constructor for the interval [<i>l</i>, <i>h</i>] is
<blockquote><a NAME="4694"></a><a NAME="4695"></a><tt>sv_interval i = sv_interval(sv_real
l, sv_real h);</tt></blockquote>
The data are <tt>i.lo</tt> and <tt>i.hi</tt>.
<p>If the ends are the wrong way round the interval is empty, and the function
<br>&nbsp;
<dl><a NAME="4696"></a><a NAME="4697"></a><tt>sv_integer sv_interval::empty();</tt></dl>

<p><br>detects this. It is true if the interval is empty, false otherwise.
The null constructor returns an empty interval.
<p><a NAME="3078"></a><a NAME="3079"></a>You can perform addition, subtraction
and multiplication on intervals, and on intervals mixed with reals. You
can also divide an interval by a real. Monadic minus is defined, too.
<p><a NAME="4698"></a><a NAME="4699"></a><a NAME="3085"></a><a NAME="3086"></a><a NAME="3087"></a>If
<tt>a</tt>
and <tt>b</tt> are intervals, then
<blockquote><tt>a &amp; b</tt></blockquote>
returns their intersection&nbsp; (which may be <tt>empty()</tt>, of course).
The union<a NAME="4700"></a><a NAME="4701"></a><a NAME="3088"></a><a NAME="3089"></a><a NAME="3090"></a>&nbsp;
of two intervals is returned by
<blockquote><tt>a | b</tt></blockquote>
which is defined to be the maximum possible range that can be got out of
either of them when considered together. The absolute value of an interval
<tt>a</tt>
is obtained from
<blockquote><a NAME="4702"></a><a NAME="4703"></a><tt>sv_interval abs(a)</tt></blockquote>
The function
<blockquote><a NAME="4704"></a><a NAME="4705"></a><tt>sv_interval pow(sv_interval
i, sv_integer e)</tt></blockquote>
raises an interval to a power. It does so keeping the bounds as tight as
possible (thus <tt>pow(i,2)</tt> will always be non-negative even if the
interval <tt>i</tt> contains 0, whereas <tt>i*i</tt> won't).
<p>There are
<tt>max<a NAME="4706"></a><a NAME="4707"></a></tt>&nbsp; and
<tt>min<a NAME="4708"></a><a NAME="4709"></a></tt>&nbsp;
functions which do the obvious thing with their two interval arguments.
The <tt>sin<a NAME="4710"></a><a NAME="4711"></a></tt>&nbsp; and
<tt>cos<a NAME="4712"></a><a NAME="4713"></a></tt>&nbsp;
of an interval are also defined, as is <i>e</i> to the power of an interval
(<tt>exp<a NAME="4714"></a><a NAME="4715"></a></tt> ). Finally, the signed
square-root function <tt>s_sqrt<a NAME="4716"></a><a NAME="4717"></a></tt>
also works on intervals.
<p>For reasons of efficiency, intervals are not checked for emptiness when
you do arithmetic and other things on them, so be warned.
<p>There is an <tt>sv_box<a NAME="4720"></a><a NAME="4721"></a></tt>&nbsp;
structure, where a box is made up from three intervals: for example
<blockquote><tt>sv_box b = sv_box(iv_x, iv_y, iv_z);</tt></blockquote>
The data are <tt>b.xi, b.yi</tt>, and
<tt>b.zi</tt>. You can also make
a box from its most negative and most positive corners using a statement
of the form
<blockquote><tt>sv_box c = sv_box(sv_point most_neg, sv_point most_pos);</tt></blockquote>
All the functions and operators that are defined for intervals work with
boxes as well by being applied to their component intervals. Where a function
is defined for a real and for an interval, the equivalent box function
takes a point and a box in the obvious way. Note that, when you take the
intersection of two boxes, <i>some</i> of the three resulting intervals
may be empty.
<p>There are other box and interval functions:
<br>&nbsp;
<dl>
<dt>
<a NAME="4718"></a><a NAME="4719"></a><a NAME="3125"></a><a NAME="3126"></a><b><tt>prim_op
same(sv_interval a, sv_interval b)</tt></b></dt>

<dl>
<dt>
returns
<tt>SV_ZERO, SV_PLUS</tt> or <tt>SV_COMP</tt> as for <a href="#4584"><tt>sv_real</tt>s</a>.</dt>
</dl>

<dt>
<b><tt>prim_op same(sv_box a, sv_box b)</tt></b></dt>

<dl>
<dt>
returns <tt>SV_ZERO, SV_PLUS</tt> or <tt>SV_COMP</tt> as for <a href="#4584"><tt>sv_real</tt>s</a>.</dt>
</dl>

<dt>
<a NAME="4722"></a><a NAME="4723"></a><a NAME="4724"></a><a NAME="4725"></a><b><tt>sv_real
sv_box::vol()</tt></b></dt>

<dd>
returns the box's volume.</dd>

<dt>
<a NAME="4726"></a><a NAME="4727"></a><b><tt>sv_point sv_box::centroid()</tt></b></dt>

<dd>
returns the box's centroid.</dd>

<dt>
<a NAME="4728"></a><a NAME="4729"></a><b><tt>sv_real sv_box::diag_sq()</tt></b></dt>

<dd>
returns the squared length of the box's diagonal.</dd>

<dt>
<a NAME="4730"></a><a NAME="4731"></a><b><tt>mem_test sv_interval::member()</tt></b></dt>

<dd>
returns SV_SOLID if the interval is all negative, SV_SURFACE if it contains
zero, and SV_AIR if it is all positive. (See the class sv_set on Page&nbsp;<a href="node9.html#SETCLASS"><img SRC="cross_ref_motif.gif" ALT="[*]" BORDER=1 height=10 width=10 align=BOTTOM></a>
for a fuller explanation.)</dd>

<dt>
<a NAME="4732"></a><a NAME="4733"></a><b><tt>mem_test sv_interval::member(sv_real
a)</tt></b></dt>

<dd>
returns SV_SOLID if a is in the interval, SV_SURFACE if it is at either
end, or SV_AIR if it is outside.</dd>

<dt>
<a NAME="4734"></a><a NAME="4735"></a><b><tt>mem_test sv_box::member(sv_point
a)</tt></b></dt>

<dd>
returns SV_SOLID if a is in the box, SV_SURFACE if it is on the surface,
or SV_AIR if it is outside.</dd>

<dt>
<a NAME="4736"></a><a NAME="4737"></a><b><tt>sv_integer sv_interval::inside(sv_interval
a)</tt></b></dt>

<dd>
returns true if a contains the interval, false otherwise.</dd>

<dt>
<a NAME="4738"></a><a NAME="4739"></a><b><tt>sv_integer sv_box::inside(sv_box
a)</tt></b></dt>

<dd>
returns true if a <i>contains</i> the box, false otherwise.</dd>

<dt>
<a NAME="4740"></a><a NAME="4741"></a><a NAME="3175"></a><a NAME="3176"></a><b><tt>sv_integer
sv_interval::tag()</tt></b></dt>

<dd>
returns the unique svLis tag&nbsp; for intervals.</dd>

<dt>
<a NAME="4742"></a><a NAME="4743"></a><b><tt>sv_integer sv_box::empty()</tt></b></dt>

<dd>
returns true if <i>all</i> the box's intervals are empty.</dd>

<dt>
<a NAME="4744"></a><a NAME="4745"></a><a NAME="3181"></a><a NAME="3182"></a><b><tt>sv_integer
sv_box::tag()</tt></b></dt>

<dd>
returns the unique svLis tag&nbsp; for boxes.</dd>

<dt>
<a NAME="4746"></a><a NAME="4747"></a><a NAME="LNBOX"></a><b><tt>sv_interval
line_box(sv_line l, sv_box b)</tt></b></dt>

<dd>
returns the parametric interval along a line that represents the part of
it in the box. This may be empty, of course.</dd>

<dt>
<a NAME="4748"></a><a NAME="4749"></a><b><tt>sv_interval sv_plane::range(sv_box
b)</tt></b></dt>

<dd>
returns the range of values that would be generated if all the points in
a box were to be substituted into the plane equation. This is an exact
calculation.</dd>

<dt>
<a NAME="4750"></a><a NAME="4751"></a><a NAME="3190"></a><b><tt>sv_point
sv_box::corner(sv_integer i)</tt></b></dt>

<dd>
returns a lexical ordering of the eight corners of a box. The value of
<tt>i
</tt>should
vary from 0 (which returns the most negative corner in all three coordinates)
to 7 (which returns the most positive).</dd>

<dt>
<a NAME="4752"></a><a NAME="4753"></a><b><tt>void box_edge(sv_integer i,
sv_integer&amp; c0, sv_integer&amp; c1)</tt></b></dt>

<dl>
<dt>
returns the indices of corners at the ends of an edge (of which there are,
of course, 12). <tt>i</tt> should have a value from 0 to 11. There are
another 7 entries (i = 12&nbsp; to 18) which give the internal edges of
the tetrahedral decomposition of a box used by the faceter.</dt>
</dl>

<dt>
<a NAME="4754"></a><a NAME="4755"></a><b><tt>sv_interval l_int_plane(sv_line
l, sv_plane f, sv_interval i)</tt></b></dt>

<dl>
<dt>
returns the part of an interval <tt>i
</tt>in the parameter space of the
line <tt>l,</tt> which is the section of it that lies in the SV_SOLID region
of the plane. The interval returned may be empty, as may <tt>i </tt>on
entry. If the line is parallel to the plane,
<tt>get_svlis_flag()
</tt>will
return NO_CROSS after a call to this function.</dt>
</dl>

<dt>
<a NAME="4756"></a><a NAME="4757"></a><a NAME="3208"></a><a NAME="3209"></a><b><tt>sv_box
sv_box::norm()</tt></b></dt>

<dd>
<b>t</b>ransforms one box to another. Imagine that the box represents all
the places where the end-points of some vectors might be (see the <a href="#ab10">grad
of a box in a primitive</a>). This returns the box that you get from that
if you were to normalize all the vectors. The box supplied must not contain
the origin (if it does, the answer goes undefined, just like attempting
to normalize a zero-length vector). Note that if you were really to normalize
all the vectors, you would get a region on the surface of the unit sphere.
The box returned by norm encloses that region.</dd>

<dt>
<a NAME="4758"></a><a NAME="4759"></a><a NAME="BXSPR"></a><a NAME="3214"></a><a NAME="3215"></a><b><tt>integer
box_spread(sv_box b, sv_point* cen, sv_real* major, sv_real* minor)</tt></b></dt>

<dd>
computes the&nbsp; centroid of a box (returned in cen), and the major and
minor principal components of the box, after it is projected into a plane
normal to the centroid vector. The principal components are normalized
by dividing them by the length of the centroid vector. If the function
returns true, the the box didn't contain the origin and the principal components
will have been set. If it returns false, then no useful information other
than the centroid is returned. This function is used to compute the range
of possible grad vectors for a primitive (see below).</dd>

<br>&nbsp;</dl>
You can take the union<a NAME="3217"></a><a NAME="3218"></a>&nbsp; or the
intersection<a NAME="3219"></a><a NAME="3220"></a>&nbsp; of boxes in just
the same way as for intervals. Note that the intersection of two boxes
may be empty in some coordinates but not others.
<br>&nbsp;
<dl>&nbsp;</dl>

<h2>
<a NAME="SECTION00934000000000000000"></a><a NAME="4761"></a><a NAME="4762"></a><a NAME="SVPRIM2"></a><a NAME="4763"></a><a NAME="4764"></a><a NAME="4765"></a><a NAME="4766"></a><a NAME="4767"></a><a NAME="4768"></a><a NAME="3235"></a>The
<tt>sv_primitive</tt>
class</h2>
<i>Files:</i> <tt><font color="#FF0000">prim.h</font>, prim.cxx, <font color="#FF0000">u_prim.cxx</font></tt>
<br>&nbsp;
<p>A primitive&nbsp; in svLis is a tree with reals, planes, and user-defined
functions as leaves, and algebraic and other operators at the nodes. A
primitive is treated as an implicit inequality to define solids (<i>p</i>(<i>x</i>,<i>y</i>,<i>z</i>)
&lt; 0 is solid, <i>p</i> > 0 is air, <i>p</i> = 0 is the surface). The
leaf primitives are built by the two constructors<a NAME="3236"></a><a NAME="3237"></a><a NAME="4769"></a><a NAME="4770"></a>
:
<blockquote>
<pre>sv_primitive a = sv_primitive(sv_real r);
sv_primitive b = sv_primitive(sv_plane f);</pre>
</blockquote>
The five arithmetic operations can then be applied to build more complicated
primitives from these:
<br>&nbsp;
<dl><b><tt>-</tt></b>
<dd>
<a NAME="4771"></a><a NAME="4772"></a>(monadic) complements the primitive
(i.e. swap solid and air).<a NAME="4773"></a><a NAME="3246"></a><a NAME="3247"></a></dd>

<dt>
<b><tt>+</tt></b></dt>

<dd>
<a NAME="4774"></a><a NAME="4775"></a>add.</dd>

<dt>
<b><tt>-</tt></b></dt>

<dd>
<a NAME="4776"></a><a NAME="4777"></a>subtract.</dd>

<dt>
<b><tt>*</tt></b></dt>

<dd>
<a NAME="4778"></a><a NAME="4779"></a>multiply.</dd>

<dt>
<b><tt>/</tt></b></dt>

<dd>
<a NAME="4780"></a><a NAME="4781"></a>divide (reals are accepted as the
divisor, but not other primitives).</dd>

<dt>
<img SRC="img5.gif" ALT="$ \wedge $" BORDER=0 height=12 width=10 align=BOTTOM></dt>

<dd>
<a NAME="4782"></a><a NAME="4783"></a>exponentiation (to a positive integer
power).</dd>

<dd>
</dd>
</dl>
You can also create transcendental functions of primitives: the <tt>sin,
cos,<a NAME="4784"></a><a NAME="4785"></a><a NAME="4786"></a><a NAME="4787"></a></tt>&nbsp;
and <tt>exp<a NAME="4788"></a><a NAME="4789"></a></tt>&nbsp; of any primitive
are defined. In addition, the signed square root is defined for primitives<a NAME="4790"></a><a NAME="4791"></a>.
Thus, if <tt>p</tt> is a primitive, you can take <tt>s_sqrt(p)</tt>. It
is often fairly easy to set up a primitive (a sphere is the obvious example)
where the potential function behaves like the signed square of the distance
from the surface. The function <tt>s_sqrt</tt> effectively square-roots
that while preserving the sign information (that is, while preserving the
distinction between inside and outside). This means that the potential
function for such primitives will be true distance. The only problem here
is with the grad vector of
<tt>s_sqrt</tt>, which rather inconveniently
acquires infinite magnitude at the primitive's surface. To fudge this svLis
actually returns the grad of <tt>p</tt> for the grad of <tt>s_sqrt(p)</tt>.
As svLis only uses directions of grad vectors internally, and not their
magnitudes, this is okay. But if you need <i>true</i> grad vectors, watch
out for <tt>s_sqrt</tt>.
<p>There is also a <tt>sign(sv_primitive p)<a NAME="4792"></a><a NAME="4793"></a></tt>&nbsp;
function that returns the sign (+1 or -1) of <tt>p</tt> at any point in
space. Note that this does <i>not</i> return 0 for points on the surface--you
should get -1 for them, but rounding will make this very ill-conditioned
anyway.
<p><a NAME="uprim"></a>You can program up your own primitives<a NAME="3283"></a><a NAME="4794"></a><a NAME="4795"></a>
. You create them with<a NAME="4796"></a><a NAME="4797"></a>
<blockquote>
<pre>sv_primitive p = sv_primitive(sv_integer up,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sv_integer ugx, sv_integer ugy, sv_integer ugz);</pre>
</blockquote>
The variable <tt>up</tt> is a flag that is passed back to the functions
in the file <tt>u_prim.cxx</tt>. You must amend that file to add the code
for your primitive. The least you must do is to add your primitive to the
following two functions:
<blockquote>
<pre>sv_real value_user(sv_integer up, sv_point q)
sv_interval range_user(sv_integer up, sv_box b)</pre>
</blockquote>
They return a potential value for your primitive at a point, and the range
of potentials in the box respectively. The values <tt>ugx, ugy</tt> and
<tt>ugz</tt>
should tag <i>x</i>, <i>y</i> and <i>z</i> components of the grad of your
primitive, which you will need to implement as well. You don't need to
worry about the second and further derivatives as far as svLis is concerned,
though you may need them for yourself, of course. The integers you supply
can have any positive values greater than <tt>S_U_PRIM</tt>, which is <tt>#define</tt>d
in <font color="#FF0000"><tt>enum_def.h</tt>.</font>
<p>If you need to be able to translate your primitive, you need to put
code in <tt>sv_primitive translate_user(sv_integer up, sv_point q)</tt>
as well, and so on for other functions. See the examples in the file
<tt><font color="#FF0000">u_prim.cxx</font></tt>for
details.
<p>As usual, <tt>sv_primitive +</tt> (or <tt>-</tt>) <tt>sv_point</tt>
in a program translates any primitive.
<p>The <tt>==<a NAME="4798"></a><a NAME="4799"></a></tt>&nbsp; and
<tt>!=<a NAME="4800"></a><a NAME="4801"></a></tt>&nbsp;
operators work on primitives <tt>a, b</tt>, and <tt>c</tt> as follows:
<blockquote>
<pre>a = b;
c = b;
if (c == a) // ---- true

a = b*c;
c = b*c;
if (c == a) // ---- false</pre>
</blockquote>
As you might imagine, the operators <tt>==</tt> and <tt>!=</tt> work on
the pointers. If two primitives point to the same thing they're equal;
if they're merely functionally equivalent, they're not. SvLis <i>never</i>
copies a primitive; once you've defined one, all other references to it
are made by copying pointers to it. This is jolly efficient. Of course,
if you translate it somewhere else in space, the result is a different
primitive, and a new one is created accordingly. If you want to compare
two different primitives for functional equivalence, use the <tt>same(...)</tt>
function below.
<p>Primitives hide their data<a NAME="3312"></a>&nbsp; (so, for instance,
you can't refer directly to <tt>a.f</tt>, which is the plane that generates
a flat primitive), but various functions return data from a given primitive:
<br>&nbsp;
<dl>
<dt>
<a NAME="4802"></a><a NAME="4803"></a><b><tt>sv_integer sv_primitive::exists()</tt></b></dt>

<dd>
true if the primitive is defined, false otherwise.&nbsp; The null constructor
makes an undefined primitive.</dd>

<dt>
<a NAME="4804"></a><a NAME="4805"></a><b><tt>prim_op same(sv_primitive
a, sv_primitive b)</tt></b></dt>

<dd>
Primitives are the same if they are set-theoretically the same; thus if
their potential functions have the same 0s and the same sign then they're
the same and this returns SV_PLUS, if not, not, and SV_ZERO is returned.
If SV_ABS is returned, then one is the absolute value of the other. If
SV_COMP is returned, then one is the complement of the other. This procedure
is conservative: if two primitives are different it will always say so.
If two are really complicated and actually the same, then occasionally
this won't be spotted.</dd>

<dt>
<a NAME="4806"></a><a NAME="4807"></a><b><tt>void sv_primitive::set_flags(sv_integer
i)</tt></b></dt>

<dd>
sets flag bits for a primitive. Each primitive carries with it an integer
flag word. Your value of
<tt>i </tt>is
<font size=-1>OR</font>ed with this
to create new flag bits. The most senior two bytes of the flag are reserved
for svLis' use, so in fact your <tt>i
</tt>value is <font size=-1>AND</font>ed
with
<tt>0x0000ffff </tt>first to protect these bits. Every instance of
a single primitive is flagged at once. Thus, if <tt>a</tt> and <tt>b </tt>are
primitives,</dd>

<dl>
<dl>
<pre>a = b;
b.set_flags(0x1071);</pre>
</dl>
will set the flags for both <tt>a</tt> and <tt>b</tt>.</dl>

<dt>
<a NAME="4808"></a><a NAME="4809"></a><b><tt>sv_integer sv_primitive::flags()</tt></b></dt>

<dd>
returns flag values from a primitive. You get the reserved bits back as
well.</dd>

<dt>
<a NAME="4810"></a><a NAME="4811"></a><b><tt>void sv_primitive::reset_flags(sv_integer
i)</tt></b></dt>

<dd>
resets the flag bits that are 1 in i to 0. The mask protecting the svLis
bits applies, as before, as does the rule about all instances of the primitive
having their bits reset.</dd>

<dt>
<a NAME="4812"></a><a NAME="4813"></a><b><tt>sv_integer sv_primitive::kind()</tt></b></dt>

<dd>
primitives can be of various kinds:</dd>

<dl>
<dd>
<tt>SV_REAL,</tt></dd>

<dd>
<tt>SV_PLANE,</tt></dd>

<dd>
<tt>SV_CYLINDER,</tt></dd>

<dd>
<tt>SV_SPHERE,</tt></dd>

<dd>
<tt>SV_CONE,</tt></dd>

<dd>
<tt>SV_TORUS,</tt></dd>

<dd>
<tt>SV_CYCLIDE or</tt></dd>

<dd>
<tt>SV_GENERAL;</tt></dd>
</dl>

<dd>
the first two are leaves in the tree, the rest are compound. The special
shapes like SV_CYLINDER are created by the functions listed below; <tt>SV_GENERAL</tt>
primitives are any that you create to make the shapes that you want. Try
to keep the primitive degree low, both for efficiency and accuracy. The
<tt>kind()</tt>
function returns the tag value of your user-defined primitive functions
for those.</dd>

<dt>
<a NAME="4814"></a><a NAME="4815"></a><b><tt>sv_real sv_primitive::real()</tt></b></dt>

<dd>
<b>i</b>f the kind is SV_REAL, this is the value.</dd>

<dt>
<a NAME="4816"></a><a NAME="4817"></a><b><tt>sv_plane sv_primitive::plane()</tt></b></dt>

<dd>
if the kind is SV_PLANE, this is the plane.</dd>

<dt>
<a NAME="4818"></a><a NAME="4819"></a><b><tt>prim_op sv_primitive::op()</tt></b></dt>

<dd>
if the primitive is compound, this is the operator: one of</dd>

<dl>
<dd>
<tt>SV_PLUS,</tt></dd>

<dd>
<tt>SV_MINUS,</tt></dd>

<dd>
<tt>SV_TIMES,</tt></dd>

<dd>
<tt>SV_DIVIDE, </tt>or</dd>

<dd>
<tt>SV_POW,</tt></dd>
</dl>

<dd>
and if it is the result of a monadic function, this will be one of</dd>

<dl>
<dd>
<tt>SV_ABS,</tt></dd>

<dd>
<tt>SV_SIGN </tt>(see below)<tt>,</tt></dd>

<dd>
<tt>SV_SIN,</tt></dd>

<dd>
<tt>SV_COS,</tt></dd>

<dd>
<tt>SV_SSQRT, </tt>or</dd>

<dd>
<tt>SV_EXP.</tt></dd>
</dl>

<dd>
A returned value of SV_COMP means that the primitive is the complement
of its first child.</dd>

<dt>
<a NAME="4820"></a><a NAME="4821"></a><b><tt>sv_integer diadic(prim_op
op)</tt></b></dt>

<dd>
returns true if the primitive operator is diadic (+, -, *, /, or&nbsp;<img SRC="img5.gif" ALT="$ \wedge $" BORDER=0 height=12 width=10 align=BOTTOM>),
false if it is a monadic absolute value, sign,&nbsp; or transcendental
function.</dd>

<dt>
<a NAME="4822"></a><a NAME="4823"></a><b><tt>sv_integer sv_primitive::degree()</tt></b></dt>

<dd>
returns the primitive's degree (highest power of x, y or z--this only makes
sense for polynomial primitives; for those involving cosines and so on
this returns a rough measure of complexity).</dd>

<dt>
<a NAME="4824"></a><a NAME="4825"></a><a NAME="4826"></a><a NAME="4827"></a><b><tt>sv_primitive
sv_primitive::child_1(),</tt></b></dt>
</dl>

<dd>
<b><tt>sv_primitive sv_primitive::child_2()</tt></b></dd>

<dl>
<dd>
are the operand primitives if the primitive is compound. If <tt>a</tt>
is a monadic function <tt>a.child_2()</tt> will be undefined, but <tt>a.child_1()</tt>
of a will be the primitive to which the function is to be applied.</dd>

<dt>
<a NAME="4828"></a><a NAME="4829"></a><a NAME="4830"></a><a NAME="4831"></a><a NAME="4832"></a><a NAME="4833"></a><a NAME="3381"></a><a NAME="3383"></a><b><tt>sv_primitive
sv_primitive::grad_x(),</tt></b></dt>
</dl>

<dd>
<b><tt>sv_primitive sv_primitive::grad_y(),</tt></b></dd>

<dd>
<b><tt>sv_primitive sv_primitive::grad_z()</tt></b></dd>

<dl>
<dl>are the partial derivatives of the primitive with respect to <i>x,
y,</i> and <i>z</i>, which together form its <i>grad</i>,&nbsp;<img SRC="img51.gif" ALT="$ \bigtriangledown $" BORDER=0 height=19 width=12 align=ABSCENTER>.&nbsp;
When a primitive is first constructed these are not worked out, as they
may never be needed.&nbsp; But as soon as one of them is called, all three
are computed and saved for future reference; that is, their evaluation
is l<i>azy</i>.&nbsp; You can take the grad of a grad to get second derivatives,
and so on.</dl>

<dt>
<a NAME="4834"></a><a NAME="4835"></a><a NAME="3393"></a><a NAME="3394"></a><b><tt>prim_op
sv_primitive::parameters(sv_integer* k, sv_real* r0, sv_real* r1, sv_real*
c, sv_plane* f, sv_point* cen, sv_line* axis)</tt></b></dt>

<dl>
<dt>
This returns the parameters of a primitive. The value of
<tt>k </tt>is
the kind; if this is SV_GENERAL no other information is returned. Otherwise,
<tt>r0</tt>
is the real for reals, and the (major) radius for other kinds,
<tt>r1</tt>
is the minor radius for tori and cyclides,
<tt>c</tt> is the radius variation
for cyclides,
<tt>f</tt> is the plane for planes,
<tt>cen </tt>is the centre
for spheres and the symmetry direction for cyclides, and
<tt>axis</tt>
is the axis for cones, cylinders, tori and cyclides.&nbsp; The <tt>prim_op</tt>
returned is one of:</dt>

<dl>
<dt>
SV_PLUS - straightforward primitive;</dt>

<dt>
SV_COMP - the primitive is complemented (<i>i.e.</i> a hollow sphere or
whatever);</dt>

<dt>
SV_TIMES - special case: scaled plane; the factor is in r0;</dt>

<dt>
SV_ABS - the primitive is thin;</dt>

<dt>
SV_SSQRT - the primitive has been sign-square-rooted.</dt>
</dl>
</dl>

<dt>
<a NAME="4836"></a><a NAME="4837"></a><b><tt>sv_primitive sv_primitive::dump_scales()</tt></b></dt>

<dd>
returns a version of a primitive with any leading scaling factors, odd
exponents, or signed square-roots removed. It is thus simpler than the
one from which it was derived, but still has the same signs and zeros.</dd>

<dt>
<a NAME="4838"></a><a NAME="4839"></a><b><tt>sv_point sv_primitive::point()</tt></b></dt>

<dd>
returns the characteristic point of a primitive. This is defined to be
the point which minimizes the sum of squared distances to all the planes
that are in the primitive's expression. This is not always well-defined
(for example, a cylinder doesn't have one), but this function is included
for completeness. Its overloaded equivalent in the sv_set class (page&nbsp;<a href="#SETPT"><img SRC="cross_ref_motif.gif" ALT="[*]" BORDER=1 height=10 width=10 align=BOTTOM></a>)
is more useful.</dd>

<dt>
<a NAME="4840"></a><a NAME="4841"></a><a NAME="3419"></a><a NAME="3420"></a><b><tt>sv_integer
sv_primitive::tag()</tt></b></dt>

<dd>
returns the unique svLis tag&nbsp; for primitives.</dd>
</dl>

<dd>
<a NAME="ab12"></a><b><tt>sv_primitive sv_primitive::deep()</tt></b></dd>

<dl>
<dd>
makes a deep copy (that is an exact copy in a different area of memory)
of the primitive.&nbsp; This is provided to make svLis efficient when shared
memory in a parallel machine is cached.&nbsp; The user should never need
to call this.</dd>
</dl>

<dd>
<a NAME="ab13"></a><b><tt>long sv_primitive::unique()</tt></b></dd>

<dl>
<dd>
This returns the <tt>long </tt>equivalent of the pointer to a primitive's
data; it is thus a value unique and unvarying to all ordinary copies (but
not deep copies) of the primitive for a given run of svLis, but it won't
be preserved across program executions, even for an identical executable
program.&nbsp; Here is an example:</dd>

<dl>
<dd>
<tt>sv_primitive p = my_prim_function();</tt></dd>

<dd>
<tt>sv_primitive q = p;</tt></dd>

<dd>
<tt>if(p.unique() == q.unique()) // ... true</tt></dd>

<dd>
<tt>q = my_prim_function();</tt></dd>

<dd>
<tt>if(p.unique() == q.unique()) // ... false</tt></dd>

<dl>
<dd>
</dd>
</dl>
</dl>
</dl>
</dl>
There are functions to build the natural quadrics, the torus and the cyclide:
<dl>&nbsp;
<dl>
<dt>
<a NAME="4842"></a><a NAME="4843"></a><a NAME="3425"></a><a NAME="3426"></a><b><tt>sv_primitive
p_cylinder(sv_line l, sv_real r)</tt></b></dt>

<dd>
is a cylinder&nbsp; with the line as its axis and the real as its radius.</dd>

<dt>
<a NAME="4844"></a><a NAME="4845"></a><a NAME="3429"></a><a NAME="3430"></a><b><tt>sv_primitive
p_cone(sv_line l, sv_real a)</tt></b></dt>

<dd>
is a cone&nbsp; with <tt>line</tt> as the axis. The <tt>sv_real a</tt>
is the cone's included angle in radians. The apex of the cone is at the
line's origin. Note that this constructs the equation of a double cone
meeting at the apex. If you only want half of it (and you probably do)
then you have to turn it into a set (see Page&nbsp;<a href="node9.html#CONESET"><img SRC="cross_ref_motif.gif" ALT="[*]" BORDER=1 height=10 width=10 align=BOTTOM></a>)
and intersect it with a plane through the apex.</dd>

<dt>
<a NAME="4846"></a><a NAME="4847"></a><a NAME="3435"></a><a NAME="3436"></a><b><tt>sv_primitive
p_sphere(sv_point p, sv_real r)</tt></b></dt>

<dd>
is a sphere; the arguments are its centre and radius respectively.</dd>

<dt>
<a NAME="4848"></a><a NAME="4849"></a><a NAME="3440"></a><a NAME="3441"></a><b><tt>sv_primitive
p_torus(sv_line l, sv_real big_r, sv_real little_r)</tt></b></dt>

<dl>
<dt>
is a torus&nbsp; with its major circle (radius <tt>big_r</tt>) perpendicular
to the line and centred at its origin. The variable <tt>little_r </tt>is
the minor radius of the torus.</dt>
</dl>

<dt>
<a NAME="4850"></a><a NAME="4851"></a><a NAME="3447"></a><a NAME="3448"></a><b><tt>sv_primitive
p_cyclide(sv_line l, sv_point sym, sv_real big_r, sv_real little_r, sv_real
rc)</tt></b></dt>

<dl>
<dt>
is a cyclide&nbsp; with its major circle (radius <tt>big_r</tt>) perpendicular
to the line and its centre at its origin. <tt>little_r + rc</tt> is the
biggest minor radius of the cyclide; <tt>little_r - rc</tt> is the smallest
minor radius of the cyclide. The cyclide is symetrical about the direction
<tt>sym</tt>,
which obviously must not be parallel to the direction of axis.</dt>
</dl>
</dl>
</dl>
All these special shapes are flagged, and you can identify them for primitive
<tt>p</tt>
by calling <tt><a href="#4812">p.kind()</a></tt>. If <i>you</i> make a
natural quadric or a torus by multiplying the appropriate planes and reals
together, svLis won't know that it is one, of course. Use the special functions
whenever you need the special shapes.
<p><a NAME="4852"></a><a NAME="4853"></a><a NAME="3464"></a><a NAME="3465"></a>If
you call
<dl>
<dl><tt>void real_distance(1);</tt></dl>
</dl>
it sets an internal flag that ensures that the common quadrics use the
<tt>s_sqrt<a NAME="4854"></a><a NAME="4855"></a></tt>&nbsp;
function to make their potential values reflect true distance. The default
is <tt>real_distance(0)</tt>, which will cause these functions to return
their usual (that is, squared) distance potential.
<p>A number of functions are provided for doing things with primitives.
Note that adding or subtracting a point (i.e. a translation), spin, mirror,
and complement all preserve the special shapes just described, and the
internal flag is kept appropriately. You can treat the special shapes as
ordinary primitives and do things like forming the product of a sphere
and a cone. The product will be an <tt>SV_GENERAL</tt>, but its children
will retain the flags for their special shapes. Here are the functions:
<dl>&nbsp;
<dl>
<dt>
<a NAME="4856"></a><a NAME="4857"></a><a NAME="3472"></a><a NAME="3473"></a><b><tt>sv_primitive
sv_primitive::spin(sv_line l, sv_real angle)</tt></b></dt>

<dl>
<dt>
rotates&nbsp; the primitive about the line through an angle supplied in
the real.</dt>
</dl>

<dt>
<a NAME="4858"></a><a NAME="4859"></a><a NAME="3476"></a><a NAME="3477"></a><b><tt>sv_primitive
sv_primitive::mirror(sv_plane m)</tt></b></dt>

<dd>
mirrors the primitive&nbsp; in the plane.</dd>

<dt>
<a NAME="4860"></a><a NAME="4861"></a><a NAME="3480"></a><a NAME="3481"></a><b><tt>sv_primitive
sv_primitive::scale(sv_point c, sv_real s)</tt></b></dt>

<dd>
scales the primitive&nbsp; about the point c by factor s, which can take
any real value other than 0.</dd>

<dt>
<a NAME="ab6565"></a><b><tt>sv_primitive sv_primitive::scale(sv_line axis,
sv_real s)</tt></b></dt>

<dl>
<dt>
scales the primitive&nbsp; in 1 dimension along axis from its origin by
factor s, which can take any real value other than 0.&nbsp; The potential
function that the primitive represents is scaled accordingly.&nbsp; This
means that, for example, if you apply this function to a primitive that's
a single plane, that plane has a multiplier appended to give it an appropriately
scaled potential function.</dt>
</dl>

<dt>
<a NAME="4862"></a><a NAME="4863"></a><a NAME="3486"></a><a NAME="3487"></a><b><tt>sv_real
sv_primitive::value(sv_point p)</tt></b></dt>

<dd>
returns the primitive's potential&nbsp; function at the point (by convention
negative values correspond to solid, positive values correspond to air).</dd>

<dt>
<a NAME="4864"></a><a NAME="4865"></a><b><tt>sv_interval sv_primitive::range(sv_box
b)</tt></b></dt>

<dd>
returns a conservative estimate of the range of potential values that a
primitive may take in a box. Unlike the plane version of this, this is
not guaranteed to be exact. But it should be if each plane leaf appears
in the primitive once only.</dd>

<dt>
<a NAME="4866"></a><a NAME="4867"></a><a NAME="3492"></a><a NAME="3494"></a><b><tt>sv_point
sv_primitive::grad(sv_point p)</tt></b></dt>

<dd>
returns the gradient, that is the grad vector at a point.</dd>

<dt>
<a NAME="ab10"></a><b><tt>sv_box sv_primitive::grad(sv_box b)</tt></b></dt>

<dd>
returns a new box containing the range of grad vectors for the primitive
in the box <tt>b</tt>. Once again, this is a conservative estimate which
is possibly wider than the actual values. Remember that things like axially-aligned
cylinders will have zero gradient along their axis, so you'll get a flat
box back from them. The <a href="#4758"><tt>box_spread
</tt>function</a>
will return an estimate of how wide-ranging the grad is.</dd>

<dt>
<a NAME="4868"></a><a NAME="4869"></a><a NAME="3501"></a><a NAME="3503"></a><b><tt>sv_primitive
abs(sv_primitive a)</tt></b></dt>

<dd>
returns the surface of a primitive. SvLis is a geometric modeller, as opposed
to a solid modeller. The distinction is that geometric modellers can store
more geometry than just solids. SvLis can store curved surfaces, curved
lines in space, and points, and work with them and solids all completely
consistently. As was mentioned above, primitives are (by default) considered
to be solid half-spaces--solid in the region of space where they are negative,
air where they are positive, and surface where they are zero. However,
if you take the absolute value of a primitive, <tt>abs(p)</tt>, the result
is a primitive that never goes negative. It thus describes an zero-thickness
sheet<a NAME="3505"></a>. If you negate such a primitive, the result is
solid everywhere but its surface. Note that the grad of one of these zero-thickness
primitives would become undefined at the surface, which is usually just
where you want it. . . . Therefore, the grad of a primitive that returns
absolute values<a NAME="3507"></a><a NAME="3509"></a> is just the same
as that of the corresponding solid primitive. So, take care when doing
such things as function minimization. You can always check for an absolute
value with
<tt>p_thin()<a NAME="4870"></a><a NAME="4871"></a></tt>&nbsp;
(below) and then apply the sign of the first (and only) child of <tt>p</tt>
to the grad to get the `correct' gradients, of course.</dd>
</dl>

<dd>
<a NAME="ab14"></a><b>i<tt>nt p_thin(sv_primitive p)</tt></b></dd>

<dl>
<dd>
returns true if the primitive is thin (that is uses the <tt>abs()</tt>
function above) or is the complement of a thin primitive, false otherwise.</dd>

<dl>&nbsp;</dl>
</dl>

<h2>
</h2>
</dl>

<h2>
<a NAME="SECTION00935000000000000000"></a><a NAME="4873"></a><a NAME="4874"></a><a NAME="4875"></a><a NAME="4876"></a><a NAME="4877"></a><a NAME="4878"></a><a NAME="SETCLASS"></a><a NAME="3528"></a>The
<tt>sv_set</tt>
class</h2>

<dl><i>Files:</i> <tt><font color="#FF0000">set.h</font>, set.cxx</tt>
<br>&nbsp;
<p>Sets&nbsp; are trees with primitives at the leaves and set-theory operators
at the nodes. They define solid shapes, surfaces, curves, and points. The
function
<blockquote><tt>sv_set s = sv_set(sv_primitive);</tt><a NAME="4879"></a><a NAME="4880"></a></blockquote>
makes a leaf, while
<blockquote><tt>sv_set(SV_NOTHING);</tt>
<br><tt>sv_set(SV_EVERYTHING);</tt></blockquote>
make the empty and universal set. You can make straight wires (in fact
the intersection of two thin planes) with
<blockquote><tt>sv_set s = sv_set(sv_line);</tt><a NAME="4881"></a><a NAME="4882"></a></blockquote>
and points <i>as sets<a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" HREF="footnode.html#3538"></a><a NAME="tex2html27" href="footnode.html#3538"></a><a NAME="tex2html27" href="footnode.html#3538"></a><a NAME="tex2html27" href="footnode.html#3538"></a><a NAME="tex2html27" href="footnode.html#3538"></a><a NAME="tex2html27" href="footnode.html#3538"></a><a NAME="tex2html27" href="footnode.html#3538"></a><a href="footnode.html#3538" NAME="tex2html27"><img SRC="foot_motif.gif" ALT="[*]" BORDER=1 height=10 width=10 align=BOTTOM></a></i>
(the intersection of three planes) with
<blockquote><tt>sv_set s = sv_set(sv_point);</tt><a NAME="4883"></a><a NAME="4884"></a><a NAME="3542"></a><a NAME="3543"></a><a NAME="3544"></a><a NAME="3545"></a></blockquote>
<a NAME="4886"></a><a NAME="4887"></a><a NAME="3549"></a><a NAME="3550"></a><a NAME="3552"></a><a NAME="3553"></a><a NAME="4889"></a><a NAME="4890"></a><a NAME="3557"></a><a NAME="3558"></a><a NAME="4892"></a><a NAME="4893"></a><a NAME="4895"></a><a NAME="4896"></a>The
four set-operators provided are union: <tt>|</tt>,&nbsp; intersection:
<tt>&amp;</tt>,&nbsp;
difference <tt>-</tt>,&nbsp; and symmetric&nbsp;&nbsp; difference
<tt>^.</tt>
When you apply these operators to <tt>SV_NOTHING</tt> and
<tt>SV_EVERYTHING</tt>
and other sets, things are kept as simple as possible (thus <tt>a &amp;
sv_set(SV_EVERYTHING)</tt> would just be <tt>a</tt>). The monadic operator
<tt>-<a NAME="4897"></a><a NAME="4898"></a><a NAME="3571"></a><a NAME="3572"></a></tt>&nbsp;
means complement and, as you might expect, adding and subtracting points
to sets translates them.
<p>When you subtract sets or take their symmetric difference the result
is internally recoded to use the -, <tt>&amp;</tt> and <tt>|</tt> operators
only.
<p>Given that svLis is a set-theoretic modeller, membership tests are being
done all the time. They can return one of three <tt>mem_test</tt> values
which are defined in <tt><font color="#FF0000">enum_def.h</font></tt>:
<br>&nbsp;
<dl><tt>SV_SOLID,</tt>
<br><tt>SV_SURFACE</tt> and
<br><tt>SV_AIR</tt>.</dl>

<p><br>It is (I hope) fairly clear that the intersection of the solid regions
of two primitives is the common solid region between them, and so on. What
of the thin primitive sheets<a NAME="3579"></a>&nbsp; made by taking <tt>abs(p)</tt>?
You can trim the surfaces that result by intersecting them with solids.
If you intersect two surfaces the result is zero or more (curving) lines
or wires in space; if you intersect three the result is zero or more points.
In this way you can construct complicated three-dimensional geometry involving
solids, bits of (curved) surface, bits of (curved) lines, and points.
<p>The operators <tt>==<a NAME="4899"></a><a NAME="4900"></a></tt>&nbsp;
and <tt>!=<a NAME="4901"></a><a NAME="4902"></a></tt>&nbsp; work for sets
in the same way as for <a href="#4798">primitives</a>: sets are equal if
they point to the same hidden data and have the same attributes.&nbsp;
Like primitives, sets hide their data, so you cannot get at members of
the structure explicitly. However, there is a collection of functions to
return data from a set:
<br>&nbsp;
<dl>
<dt>
<a NAME="4905"></a><a NAME="4906"></a><b><tt>void sv_set::set_flags(sv_integer
i)</tt></b></dt>

<dd>
and the following two functions work in exactly the same way as their overloaded
equivalent functions do for
<a href="#4807">primitives</a>.</dd>

<dt>
<a NAME="4907"></a><a NAME="4908"></a><b><tt>sv_integer sv_set::flags()</tt></b></dt>

<dt>
<a NAME="4909"></a><a NAME="4910"></a><b><tt>void sv_set::reset_flags(sv_integer
i)</tt></b></dt>
</dl>

<dd>
<a NAME="4903"></a><a NAME="4904"></a><a NAME="SETEX"></a><b><tt>sv_integer
sv_set::exists()</tt></b></dd>

<dl>
<dd>
returns true if the set exists, false otherwise.</dd>

<dt>
<a NAME="4911"></a><a NAME="4912"></a><b><tt>sv_integer sv_set::contents()</tt></b></dt>

<dd>
returns a count of the number of primitives that go to make up a set. The
value for SV_NOTHING is defined as zero, and SV_EVERYTHING is represented
by -1. A value of 1 returned by <tt>s.contents() </tt>indicates that <tt>s
</tt>is
a leaf set with just one primitive in.</dd>

<dt>
<a NAME="4913"></a><a NAME="4914"></a><b><tt>set_op sv_set::op()</tt></b></dt>

<dd>
returns either SV_UNION or SV_INTERSECTION for a non-leaf set.</dd>

<dt>
<a NAME="4915"></a><a NAME="4916"></a><b><tt>sv_primitive sv_set::primitive()</tt></b></dt>

<dd>
returns the primitive for a leaf set.</dd>
</dl>
</dl>

<dl><a NAME="simpfirst"></a>SvLis always stores the least complicated set
as the first operand (or child). When a set is being evaluated, it is often
only necessary to evaluate one operand to find the answer (for example,
if a point is in set <tt>a</tt>, and svLis is evaluating <tt>a | b,</tt>
then the fact that <tt>a </tt>returns SV_SOLID is enough to know the answer,
and <tt>b</tt> is never even looked at).
<br>&nbsp;
<dl>
<dt>
<a NAME="4917"></a><a NAME="4918"></a><a NAME="4919"></a><a NAME="4920"></a><b><tt>sv_set
sv_set::child_1()</tt></b></dt>

<dt>
<b><tt>sv_set sv_set::child_2()</tt></b></dt>

<dl>
<dt>
returns the set-operands of a non-leaf set.</dt>
</dl>

<dt>
<a NAME="SETPT"></a><a NAME="4921"></a><a NAME="4922"></a><a NAME="3626"></a><b><tt>sv_point
sv_set::point()</tt></b></dt>

<dd>
returns the characteristic point&nbsp; of a set. This is defined to be
the point which minimizes the sum of squared distances to all the planes
that are in the set's primitives' expressions. The point serves to locate
the set (for simple objects it often--though not always--coincides with
the centroid)<a NAME="3627"></a>&nbsp; and is much faster and more accurate
to compute than the centroid of the set. This function is always well-defined
for bounded sets, but not so for some unbounded ones (like an infinitely
long cylinder, for example). A call to get_svlis_flag() immediately after
a call to this function will return a non-zero value if the characteristic
point is not well-defined.</dd>

<dt>
<a NAME="4923"></a><a NAME="4924"></a><a NAME="3632"></a><b><tt>sv_set
sv_set::regularize()</tt></b></dt>

<dd>
For simple sets (those with contents less than 3), this uses the <tt><a href="#4958">same()</a></tt>
function to check for things such as sets which are intersected with their
complement (giving the null set) and so on, and returns a possibly simplified
set depending upon what is found out by same. Sets with contents greater
than 3 are unaffected.</dd>

<dt>
<a NAME="4925"></a><a NAME="4926"></a><a NAME="3637"></a><a NAME="3638"></a><b><tt>sv_integer
sv_set::tag()</tt></b></dt>

<dd>
returns the unique svLis tag&nbsp; for sets.</dd>
</dl>

<dd>
<a NAME="ab19"></a><b><tt>sv_set sv_set::deep()</tt></b></dd>

<dl>
<dd>
returns a deep copy of the set.&nbsp; The user should never normally call
this function.</dd>
</dl>

<dd>
<a NAME="ab20"></a><b><tt>long sv_set::unique()</tt></b></dd>

<dl>
<dd>
works the same as the similar function for <a href="#ab13">primitives.</a></dd>
</dl>
</dl>

<dl>There are functions to return simple shapes as sets. They are:
<br>&nbsp;
<dl>
<dt>
<a NAME="4927"></a><a NAME="4928"></a><a NAME="4929"></a><a NAME="4930"></a><b><tt>sv_set
cuboid(sv_point most_neg, sv_point most_pos)</tt></b></dt>
</dl>

<dd>
<a NAME="4931"></a><a NAME="4932"></a><a NAME="BOXCUBE"></a><a NAME="3649"></a><b><tt>sv_set
cuboid(sv_box b)</tt></b></dd>

<dl>
<dd>
both generate the intersection of six planes needed to represent the cuboid&nbsp;
required.</dd>

<dt>
<a NAME="4933"></a><a NAME="4934"></a><a NAME="3652"></a><a NAME="3653"></a><b><tt>sv_set
cylinder(sv_line l, sv_real r)</tt></b></dt>

<dd>
returns a cylinder&nbsp; with l as its axis of radius r.</dd>

<dt>
<a NAME="4935"></a><a NAME="4936"></a><a NAME="CONESET"></a><a NAME="3659"></a><a NAME="3660"></a><b><tt>sv_set
cone(sv_line l, sv_real angle)</tt></b></dt>

<dd>
returns a cone. Or rather half a cone: the half that points the same way
as the line.</dd>

<dt>
<a NAME="4937"></a><a NAME="4938"></a><a NAME="3664"></a><a NAME="3665"></a><b><tt>sv_set
sphere(sv_point p, sv_real r)</tt></b></dt>

<dd>
returns a sphere&nbsp; centred at p of radius r.</dd>

<dt>
<a NAME="4939"></a><a NAME="4940"></a><a NAME="3670"></a><a NAME="3671"></a><b><tt>sv_set
torus(sv_line l, sv_real big_r, sv_real little_r)</tt></b></dt>

<dd>
returns a torus&nbsp; the major circle of which is perpendicular to the
line, and which has its centre at the line's origin. The variable <tt>little_r
</tt>is
the torus's minor radius.</dd>

<dt>
<a NAME="3676"></a><a NAME="3677"></a><a NAME="4941"></a><a NAME="4942"></a><b><tt>sv_set
cyclide(sv_line l, sv_point sym, sv_real big_r, sv_real little_r, sv_real
rc)</tt></b></dt>

<dl>
<dt>
is a cyclide&nbsp; with its major circle (radius <tt>big_r</tt>) perpendicular
to the line and which has its centre at its origin. l<tt>ittle_r + rc </tt>is
the biggest minor radius of the cyclide; <tt>little_r - rc </tt>is the
smallest minor radius of the cyclide. The cyclide is symetrical about the
direction <tt>sym</tt>, which obviously must not be parallel to the direction
of <tt>axis</tt>.</dt>
</dl>
</dl>
</dl>

<p><br><a NAME="4943"></a><a NAME="4944"></a><a NAME="3687"></a>There is
also a collection of such functions that return surface-primitive sets
called <tt>thin_cylinder</tt>&nbsp; and so on. They have exactly the same
arguments as the functions listed above.
<p>A number of utilities work with sets:
<br>&nbsp;
<dl>
<dl>
<dt>
<a NAME="4945"></a><a NAME="4946"></a><a NAME="3691"></a><a NAME="3692"></a><b><tt>mem_test
sv_set::member(sv_point p, sv_primitive known_surface[])</tt></b></dt>

<dt>
<b><tt>mem_test sv_set::member(sv_point p)</tt></b></dt>

<dd>
performs a membership test&nbsp; classifying the point against the set.
If you know that the point is on the SV_SURFACE of one or more primitives
(for example, if it was generated by a <a href="#RAYT">ray-test</a> into
them), then&nbsp; call the first of these functions and list them in the
array known_surface[]--this will ensure that the set regularization works
properly and efficiently.<a NAME="4947"></a><a NAME="3696"></a>&nbsp; Terminate
the list with an undefined primitive. If there are no known surfaces call
the second function.</dd>

<dt>
<a NAME="4948"></a><a NAME="4949"></a><a NAME="3699"></a><a NAME="3700"></a><b><tt>sv_set
sv_set::prune(sv_box b)</tt></b></dt>

<dd>
<i>prunes
</i>the set to the box, returning a set that is, in general,
simpler than the original and which can validly represent it <i>only inside
the box.</i></dd>

<dt>
<a NAME="4950"></a><a NAME="4951"></a><a NAME="3705"></a><b><tt>void regular_prune(sv_integer
p)</tt></b></dt>

<dd>
Calling this with a true value for p forces the pruner to call the regularize()
function for the sets it creates. A false value turns this behavior off;
this is the default.</dd>

<dt>
<a NAME="4952"></a><a NAME="4953"></a><a NAME="3712"></a><a NAME="3713"></a><b><tt>sv_set
sv_set::spin(sv_line l, sv_real a)</tt></b></dt>

<dd>
rotates&nbsp; the set about the line through an angle a.</dd>

<dt>
<a NAME="4954"></a><a NAME="4955"></a><a NAME="3717"></a><a NAME="3718"></a><b><tt>sv_set
sv_set::mirror(sv_plane m)</tt></b></dt>

<dd>
returns the mirror&nbsp; image of the set in m.</dd>

<dt>
<a NAME="4956"></a><a NAME="4957"></a><a NAME="3722"></a><a NAME="3723"></a><b><tt>sv_set
sv_set::scale(sv_point c, sv_real s)</tt></b></dt>

<dd>
scales the set&nbsp; about the point c by factor s.</dd>

<dt>
<b><tt>sv_set sv_set::scale(sv_line axis, sv_real s)</tt></b></dt>

<dl>
<dt>
scales the set&nbsp; along the line <tt>axis</tt> from its origin in 1
dimension&nbsp; by factor s.</dt>
</dl>

<dt>
<a NAME="4958"></a><a NAME="4959"></a><b><tt>prim_op same(sv_set a, sv_set
b)</tt></b></dt>

<dd>
tells you if two sets are the same within tolerance. This, like its <a href="#4804">overloaded
equivalent for primitives</a>, is a conservative function. It walks the
trees, comparing them, and applies the same function to the primitives
at the leaves. Note that the set same function is purely concerned with
geometry; it completely ignores any attribute information.</dd>

<dt>
<a NAME="4960"></a><a NAME="4961"></a><a NAME="3732"></a><a NAME="3733"></a><b><tt>sv_real
s_set::value(sv_point p, sv_set* winner)</tt></b></dt>

<dd>
returns the potential&nbsp; corresponding to a point. Recollecting the
convention that inside a primitive is where its potential is negative and
outside is where it's positive, the &amp; operation is the same as the
maximum of the potentials of its operands (that is it goes positive when
either of them do, and is only negative when both are), and the | operation
is the same as the minimum (when either operand giving a negative results
in a negative). You may need to think about this a bit, and maybe draw
a Venn diagram. The value function applies this equivalence to a set, and
returns the resulting potential value, and the leaf set (i.e. the primitive)
that gave rise to it (in *winner). This is rather slower than doing a membership
test of the point, but it gives you more information.</dd>

<dt>
<a NAME="4962"></a><a NAME="4963"></a><a NAME="3741"></a><a NAME="3742"></a><b><tt>sv_intervalsv_set::range(sv_box
b, sv_set* w_lo, sv_set* w_hi)</tt></b></dt>

<dl>
<dt>
does the same as the value function above, but returns the range&nbsp;
of potential values inside a box, together with the `winning' sets that
generated the low and high ends of the interval.</dt>
</dl>

<dt>
<a NAME="ab7589"></a><b><tt>sv_point sv_set::grad(const sv_point&amp; p,
sv_real&amp; v)</tt></b></dt>

<dl>
<dt>
The <tt>value</tt> function returned argument <tt>winner</tt> allows the
grad of a set to be defined - the grad of a set at a point is&nbsp;&nbsp;
the grad of the winning set's primitive.&nbsp; This has the same potential
in the neighbourhood of the point as the set, except when the point is
on an edge or a corner.&nbsp; In that case you get back the grad of one
of those leaf sets contributing to the feature.&nbsp; The potential value
of the set at <tt>p</tt> is returned as a side-effect in <tt>v</tt>.</dt>
</dl>

<dt>
<a NAME="ab21"></a><b><tt>sv_integer sv_set::max_degree()</tt></b></dt>

<dd>
returns the maximum <a href="#4822">degree&nbsp;</a> out of all the primitives
in the set.</dd>

<dt>
<a NAME="9104"></a><b><tt>sv_set sv_set::disjunctive_form()</tt></b></dt>

<dd>
This returns a new set that is the set&nbsp; in its disjunctive form (that
is, it distributes unions over intersections). Note that this is an exponentially-hard
problem, so don't do it for sets with a contents much bigger than, say,
10, unless you want to wait a while and use lots of memory.</dd>

<dt>
<a NAME="9105"></a><b><tt><a href="#5162">sv_set_list</a> sv_set::list_products()</tt></b></dt>

<dd>
This returns a list that is the disjunctive form (see above) of the set
split into its intersected components. In other words all the unions in
the disjunctive form have been thrown away, and you've got a list where
each list entry is a component that just contains intersections.</dd>

<dt>
<a NAME="4964"></a><a NAME="4965"></a><a NAME="3745"></a><a NAME="3746"></a><b><tt>sv_set
sv_set::colour(sv_point col)</tt></b></dt>

<dd>
attaches a colour&nbsp; to a set using <a href="#4979">attributes</a>.
The red, green, and blue values for the colour should lie between 0 and
1. Red is supplied in col.x, green in col.y, and blue in col.z.</dd>

<dt>
<a NAME="4966"></a><a NAME="4967"></a><b><tt>sv_point sv_set::colour()</tt></b></dt>

<dd>
returns the colour of a set (if you've attached one; if you haven't you
get a default medium grey back).</dd>

<dt>
<a NAME="4968"></a><a NAME="4969"></a><a NAME="3754"></a><b><tt>sv_set
sv_set::name(char* str)</tt></b></dt>

<dd>
<b>a</b>ttaches a string&nbsp; pointer to a set using <a href="#4979">attributes</a>.</dd>

<dt>
<b><tt>char* sv_set::name()</tt></b></dt>

<dd>
returns the text string associated with a set (if you've attached one;
if you haven't you get a 0 pointer back).</dd>

<dt>
<a NAME="4970"></a><a NAME="4971"></a><b><tt>sv_set sv_set::surface(sv_surface
sf)</tt></b></dt>

<dd>
attaches surface characteristics (see the <tt>sv_surface </tt>class on
page&nbsp;<a href="node9.html#SURF"><img SRC="cross_ref_motif.gif" ALT="[*]" BORDER=1 height=10 width=10 align=BOTTOM></a>)
to a set using <a href="#4979">attributes</a>.</dd>

<dt>
<b><tt>sv_surface sv_set::surface()</tt></b></dt>

<dd>
returns the surface associated with a set (if you've attached one; if you
haven't you get the default surface back).</dd>

<dt>
<a NAME="4972"></a><a NAME="4973"></a><a NAME="3761"></a><a NAME="3762"></a><b><tt>sv_set
sv_set::polygon(sv_p_gon* pg)</tt></b></dt>

<dd>
attaches a polygon&nbsp; pointer (see Page&nbsp;<a href="node9.html#POLYGON"><img SRC="cross_ref_motif.gif" ALT="[*]" BORDER=1 height=10 width=10 align=BOTTOM></a>)
to a set using <a href="#4979">attributes</a>. This is not normally called
by the user.</dd>
</dl>

<dl>
<dt>
<a NAME="4974"></a><a NAME="4975"></a><b><tt>sv_integer sv_set::polygon_count()</tt></b></dt>

<dd>
returns a count of the polygons attached to the set as attributes.</dd>

<dt>
<a NAME="4976"></a><a NAME="4977"></a><b><tt>sv_p_gon* sv_set::polygon()</tt></b></dt>

<dd>
returns the polygon pointer associated with a set (if you've attached one;
if you haven't you get a 0 pointer back). Note that if there is more than
one polygon attached to a set in its attribute list, this only gives you
back the first one; if you want them all, you have to retrieve the set's
attributes and <a href="#ab201">scan through them</a> looking for polygons.</dd>
</dl>
</dl>
For details of how to attach attributes in general to a set, see the <a href="#4987">next
section.</a>
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<h3>
<a NAME="SECTION00936000000000000000"></a><a NAME="4979"></a><a NAME="4980"></a><a NAME="4981"></a><a NAME="4982"></a><a NAME="4983"></a><a NAME="4984"></a><a NAME="ATTRIBUTE"></a><a NAME="3780"></a>The
<tt>sv_attribute</tt>
class</h3>
<i>Files:</i> <tt><font color="#FF0000">attrib.h</font>, attrib.cxx,
<font color="#FF0000">u_attrib.cxx</font></tt>
<p>Attributes are a collection of integer tag values and pointers to a
user-defined class called <tt>sv_user_attribute</tt>, terminated by a null
attribute. You can, of course, add your own kinds of attribute. See the
files <tt><font color="#FF0000">u_attrib.h</font></tt> and <tt><font color="#FF0000">u_attrib.cxx</font></tt>
for details.&nbsp; Attributes are attached to sets.
<blockquote>&nbsp;<tt>sv_attribute a = sv_attribute(sv_integer tag);</tt></blockquote>
<a NAME="4985"></a><a NAME="4986"></a>makes an attribute with just the
tag value supplied (<i>i.e.</i> with no user attribute), and
<blockquote><tt>sv_attribute a = sv_attribute(sv_integer tag, new sv_user_attribute((void*)
my_pointer));</tt></blockquote>
<a NAME="4989"></a><a NAME="4990"></a>makes an attribute with an
<tt>sv_user_attribute</tt>
associated with it. The pointer
<tt>my_pointer </tt>can be a pointer to
anything you like. The files <tt><font color="#FF0000">u_attrib.h</font></tt>and
<tt><font color="#FF0000">u_attrib.cxx</font></tt>contain
the definition of <tt>sv_user_attribute</tt> which you can extend to suit
your own needs; svLis uses the user-attributes already defined in those
files, so modify those parts at your peril.
<br><a NAME="4987"></a><a NAME="4988"></a>The set member function
<dl>
<dl>
<dt>
<tt>sv_set sv_set::attribute(sv_attribute a);</tt></dt>
</dl>
</dl>

<dt>
returns a copy of the set with the attribute attached. Any old attributes
will be retained by the original set, but replaced in the copy.&nbsp; The
function</dt>

<dl>
<dl>
<dt>
<tt>sv_attribute sv_set::attribute();</tt></dt>
</dl>
</dl>

<dt>
returns the attributes of a set.</dt>

<dt>
<a NAME="ab201"></a>Attributes form a linked list, and the same type of
thing may be recorded in different places in the list.&nbsp; Suppose, for
example, that you wanted to extract all the polygons from an attribute.&nbsp;
You would write code like:</dt>

<dl>
<dl>
<pre>sv_attribute a;
sv_user_attribute u;
sv_p_gon* pg;

a = get_attribute_from_somewhere();

while(a.<a href="#5025">exists()</a>)
{
&nbsp;&nbsp;&nbsp; if(a.<a href="#5021">tag_val()</a> == -pg-><a href="#5158">tag()</a>)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u = a.<a href="#ab200">user_attribute()</a>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pg = (sv_p_gon*)u->pointer;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Do whatever you want with
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // polygon pg.
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; a = a.<a href="#5028">next()</a>;
}</pre>
</dl>
</dl>
Note that the tag used to identify the attribute is minus the svLis tag
value for the entity.&nbsp; All svLis types used as attributes use their
own tags in this way.&nbsp; Positive tags are reserved for the user to
employ.
<p><a NAME="3800"></a><a NAME="3801"></a>The rules for attribute inheritance&nbsp;
are simple: an attribute list for a set is recursively inherited by all
children (i.e. operands) of that set that don't themselves have attributes.
As soon as a child is encountered that has an attribute list, then that
attribute list becomes the one inherited by all that set's children.
<p>It may well be the case that when you union or intersect two sets, or
you transform them, you also want to do something with the attributes attached
to them (particularly if those attributes contain geometrical information).
The following functions (defined in <tt><font color="#FF0000">u_attrib.cxx</font></tt>so
you can alter them) do nothing but return the set <tt>result</tt> in their
form as distributed. But you can change them to pick up the attributes
of the result or original sets and do whatever you like. Every time a set
is unioned or intersected or transformed by svLis the appropriate procedure
will be called for you.
<dl>
<dl>
<dt>
<a NAME="4991"></a><a NAME="4992"></a><b><tt>sv_set att_union(sv_set result,
sv_set arg_1, sv_set arg_2)</tt></b></dt>

<dl>
<dt>
is called every time svLis unions two sets (<tt>arg_1</tt> and <tt>arg_2</tt>).
The answer is <tt>result</tt>. You can make this function attach whatever
attribute you like to <tt>result
</tt>and return it; svLis will then return
that as the answer to the union operation.</dt>
</dl>

<dt>
<a NAME="4993"></a><a NAME="4994"></a><b><tt>sv_set att_intersection(sv_set
result, sv_set arg_1, sv_set arg_2)</tt></b></dt>

<dl>
<dt>
is called every time svLis intersects two sets (<tt>arg_1</tt> and <tt>arg_2</tt>).</dt>
</dl>

<dt>
<a NAME="4995"></a><a NAME="4996"></a><b><tt>sv_set att_slide(sv_set result,
sv_set arg_1, sv_point arg_2)</tt></b></dt>

<dl>
<dt>
is called every time svLis adds a point to a set to create a translation.</dt>
</dl>

<dt>
<a NAME="4997"></a><a NAME="4998"></a><b><tt>sv_set att_spin(sv_set result,
sv_set arg_1, sv_line arg_2, sv_real arg_3)</tt></b></dt>

<dl>
<dt>
is called every time svLis spins a set.</dt>
</dl>

<dt>
<a NAME="4999"></a><a NAME="5000"></a><b><tt>sv_set att_mirror(sv_set result,
sv_set arg_1, sv_plane arg_2)</tt></b></dt>

<dl>
<dt>
is called every time svLis mirrors a set.</dt>
</dl>

<dt>
<a NAME="5001"></a><a NAME="5002"></a><b><tt>sv_set att_scale(sv_set result,
sv_set arg_1, sv_point arg_2, sv_real arg_3)</tt></b></dt>

<dl>
<dt>
is called every time svLis scales a set.</dt>
</dl>

<dt>
<a NAME="5003"></a><a NAME="5004"></a><b><tt>sv_set att_prune(sv_set result,
sv_set arg_1, sv_box arg_2)</tt></b></dt>

<dl>
<dt>
is called every time svLis prunes a set.</dt>
</dl>

<dt>
<a NAME="5005"></a><a NAME="5006"></a><b><tt>sv_set att_complement(sv_set
result, sv_set arg_1)</tt></b></dt>

<dd>
is called whenever a set is complemented.</dd>
</dl>
</dl>

<p><br>Here are the other attribute functions:
<br>&nbsp;
<dl>
<dl>
<dt>
<a NAME="5007"></a><a NAME="5008"></a><b><tt>sv_attribute merge(sv_attribute
a, sv_attribute b)</tt></b></dt>

<dl>
<dt>
merges the attribute collections <tt>a </tt>and <tt>b </tt>to form their
union. Common attributes will appear only once in the result, thus it is
not possible to have an attribute collection with more than one copy of
an attribute in. Attributes are considered to be the same if they have
the same tag value and point to the same user attribute.&nbsp; The | operator
(and &amp;, -, and ^ for the next functions below) are deliberately not
overloaded to perform this operation (though you can do so yourself if
you wish, of course) because it would make code involving sets and attributes
confusing and hard to read.</dt>
</dl>

<dt>
<a NAME="5009"></a><a NAME="5010"></a><b><tt>sv_attribute overlap(sv_attribute
a, sv_attribute b)</tt></b></dt>

<dl>
<dt>
intersects the collections
<tt>a</tt> and <tt>b.</tt> The result may be
null, of course--test this with the
<tt>exists()
</tt>member function below.</dt>
</dl>

<dt>
<b><tt>sv_attribute overlap(sv_attribute a, sv_integer t)</tt></b></dt>

<dl>
<dt>
pulls out all the attributes with the tag value, <tt>t.</tt></dt>
</dl>

<dt>
<a NAME="5011"></a><a NAME="5012"></a><b><tt>sv_attribute remove(sv_attribute
a, sv_attribute b)</tt></b></dt>

<dl>
<dt>
removes any attributes that are in b from the collection a.</dt>
</dl>

<dt>
<b><tt>sv_attribute remove(sv_attribute a, sv_integer t)</tt></b></dt>

<dl>
<dt>
removes all the attributes with the tag value, <tt>t.</tt></dt>
</dl>

<dt>
<a NAME="5013"></a><a NAME="5014"></a><b><tt>sv_attribute ex_or(sv_set_list
a, sv_set_list b)</tt></b></dt>

<dl>
<dt>
does an exclusive OR on the two collections--the same as the symmetric
difference.</dt>
</dl>

<dt>
<a NAME="ab27"></a><b><tt>sv_attribute sv_attribute::replace(sv_attribute
a)</tt></b></dt>

<dl>
<dt>
returns an attribute collection with all the attributes with the same tag
value as <tt>a </tt>removed, and <tt>a </tt>inserted.</dt>
</dl>

<dt>
<a NAME="ab200"></a><b><tt>sv_user_attribute sv_attribute::user_attribute()</tt></b></dt>

<dl>
<dt>
returns the user attribute associated with the attribute.</dt>
</dl>

<dt>
<a NAME="ab28"></a><b><tt>sv_attribute sv_attribute::tag_find(sv_integer
t)</tt></b></dt>

<dl>
<dt>
finds the first attribute in the collection with the tag value <tt>t<b>.</b></tt></dt>
</dl>

<dt>
<a NAME="5015"></a><a NAME="5016"></a><b><tt>void sv_attribute::set_flags(sv_integer
i)</tt></b></dt>

<dl>
<dt>
together with the following two functions, this works in exactly the same
way as the corresponding overloaded equivalent functions do for
<a href="#4807">primitives</a>
(and sets).</dt>
</dl>

<dt>
<a NAME="5017"></a><a NAME="5018"></a><b><tt>sv_integer sv_attribute::flags()</tt></b></dt>

<dt>
<a NAME="5019"></a><a NAME="5020"></a><b><tt>void sv_attribute::reset_flags(sv_integer
i)</tt></b></dt>

<dt>
<a NAME="ab25"></a><b><tt>sv_attribute sv_attribute::deep()</tt></b></dt>

<dl>
<dt>
returns a deep copy of the attribute&nbsp; The user should never normally
call this function.</dt>
</dl>

<dt>
<a NAME="ab26"></a><b><tt>long sv_attribute::unique()</tt></b></dt>

<dl>
<dt>
works the same as the similar function for <a href="#ab13">primitives.</a></dt>
</dl>

<dt>
<a NAME="5021"></a><a NAME="5022"></a><b><tt>sv_integer sv_attribute::tag_val()</tt></b></dt>

<dl>
<dt>
returns the tag value associated with an attribute. Not to be confused
with....</dt>
</dl>

<dt>
<a NAME="5023"></a><a NAME="5024"></a><b><tt>sv_integer sv_attribute::tag()</tt></b></dt>

<dl>
<dt>
returns the svLis tag of attributes in general, so you can use attributes
as attributes (if you see what I mean).</dt>
</dl>

<dt>
<a NAME="5025"></a><a NAME="5026"></a><b><tt>sv_integer sv_attribute::exists()</tt></b></dt>

<dl>
<dt>
returns true if the attribute is defined, false otherwise. This can be
used to detect the end of the collection when you pull the members of it
out one-by-one using the <tt>next()</tt> member function (see below).</dt>
</dl>

<dt>
<a NAME="5027"></a><a NAME="5028"></a><b><tt>sv_attribute sv_attribute::next()</tt></b></dt>

<dl>
<dt>
returns the next attribute in the collection after the one for which the
function is called. To get all the individual attributes out of a collection,
<tt>ac</tt>,
you would write code like (see also <a href="#ab201">here</a>):</dt>
</dl>

<dl>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sv_attribute temp = ac;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(temp.exists())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Do whatever you want to do with individual
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // attribute temp...

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = temp.next();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</pre>
</dl>
</dl>
The <tt>==</tt> and <tt>!= </tt>operators are defined for attributes. Two
attributes are equal if each list contains exactly the same attributes
and tags (though they may not come out in the same order from the next
function); otherwise they are not equal.
<br>&nbsp;
<dl>
<dt>
<a NAME="5029"></a><a NAME="5030"></a><b><tt>sv_integer sv_attribute::count()</tt></b></dt>

<dd>
returns the number of attributes in the collection (which may be 0, of
course).</dd>

<dt>
<a NAME="5031"></a><a NAME="5032"></a><b><tt>sv_attribute sv_attribute::tag_find(sv_integer
tag)</tt></b></dt>

<dl>searches the collection of attributes and returns the first encountered
with tag value <tt>tag</tt>. This is quicker (though less general) than
calling <tt>overlap</tt> for the tag value. If no attribute in the collection
has that tag, the null attribute is returned.</dl>

<dt>
<a NAME="5033"></a><a NAME="5034"></a><a NAME="3893"></a><b><tt>sv_integer
sv_set::has_attribute()</tt></b></dt>

<dd>
returns true if the set has an attribute, false otherwise.</dd>

<dt>
<a NAME="5035"></a><a NAME="5036"></a><b><tt>sv_attribute sv_set::attribute()</tt></b></dt>

<dd>
returns the attribute of a set (if any). Check with <tt>s.has_attribute()</tt>
first, or check the result with <tt>exists().</tt></dd>

<dt>
<a NAME="5037"></a><a NAME="5038"></a><b><tt>sv_set sv_set::attribute(sv_attribute
a)</tt></b></dt>

<dl>returns a set geometrically identical to that for which the member
function was called, but with attribute
<tt>a.</tt> Any old attributes
will be retained by the original, but lost in the returned set.</dl>

<dt>
<a NAME="5039"></a><a NAME="5040"></a><b><tt>sv_set sv_set::strip_attributes()</tt></b></dt>

<dd>
returns a copy of the set with all its attributes stripped off.</dd>

<dt>
<a NAME="5041"></a><a NAME="5042"></a><b><tt>sv_attribute sv_set::inherit(sv_set
node)</tt></b></dt>

<dd>
resolves attribute inheritance. The set <tt>node</tt> is the one you want
to know the attribute of. The set for which the function has been called
contains node somewhere in its tree. This function searches that set tree
keeping track of attributes, and tells you the attribute that node has.
If <tt>s.inherit()</tt> returns a non-existent attribute, <tt>node</tt>
either had no attribute or the required one wasn't in the tree below <tt>s.</tt>
In general, it is better to run the
<tt>percolate()</tt> function once
(see below) to find the inherited attribute of a set in the middle of the
tree if you wish to do that several times--it's more efficient. Only use
<tt>inherit
</tt>for
isolated queries.</dd>

<dt>
<a NAME="5043"></a><a NAME="5044"></a><b><tt>sv_set sv_set::percolate()</tt></b></dt>

<dd>
percolate returns a copy of the set with all its attributes copied down
to all the nodes that inherit them. Note that, as attributes use svLis's
usual pointer and reference count scheme, this is pretty efficient, and
doesn't use much more memory than the unpercolated set. When you've finished
building a set it's usually a good idea to call this function before doing
anything with it like rendering it or whatever.</dd>
</dl>
</dl>

<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<h3>
<a NAME="SECTION009312000000000000000"></a><a NAME="5161"></a><a NAME="5162"></a><a NAME="5163"></a><a NAME="5164"></a><a NAME="5165"></a><a NAME="5166"></a><a NAME="SETL"></a><a NAME="4146"></a>The
<tt>sv_set_list</tt>
class</h3>
<i>Files:</i> <tt><font color="#FF0000">set.h</font>, set.cxx</tt>
<br>&nbsp;
<p>The class <tt>sv_set_list</tt> maintains lists&nbsp; of sets. You start
a list off with a single set:<a NAME="5167"></a><a NAME="5168"></a>
<br>&nbsp;
<blockquote><tt>sv_set_list sl = sv_set_list(sv_set s);</tt></blockquote>

<p><br>The main use of lists of sets is in <a href="#5203">the <tt>sv_model</tt>
class</a>. The following functions are provided for lists of sets:
<dl>
<dl>
<dt>
<a NAME="5169"></a><a NAME="5170"></a><b><tt>sv_set_list merge(sv_set_list
a, sv_set_list b)</tt></b></dt>

<dd>
merges the lists
<tt>a </tt>and <tt>b</tt> to form their union. Common
sets will appear only once in the result, thus it is not possible to have
a set list with more than one copy of a set in. Sets are considered different
if their attributes are different, so the same geometry can appear more
than once.&nbsp; As there is a constructor for making a set list from a
set, you can put a single set as either or both arguments instead of a
set list.&nbsp; This is also true for the following three functions.</dd>

<dt>
<a NAME="5171"></a><a NAME="5172"></a><b><tt>sv_set_list overlap(sv_set_list
a, sv_set_list b)</tt></b></dt>

<dd>
<b>i</b>ntersects the lists
<tt>a</tt> and <tt>b.</tt> The result may be
null, of course--test this with the
<tt>exists()</tt> member function below.</dd>

<dt>
<a NAME="5173"></a><a NAME="5174"></a><b><tt>sv_set_list remove(sv_set_list
a, sv_set_list b)</tt></b></dt>

<dd>
removes any sets that are in <tt>b
</tt>from the list <tt>a.</tt></dd>

<dt>
<a NAME="5175"></a><a NAME="5176"></a><b><tt>sv_set_list ex_or(sv_set_list
a, sv_set_list b)</tt></b></dt>

<dd>
does an exclusive OR on the two lists--the same as the symmetric difference.</dd>

<dt>
<a NAME="5177"></a><a NAME="5178"></a><b><tt>void sv_set_list::set_flags(sv_integer
i)</tt></b></dt>

<dd>
and the following two functions work in exactly the same way as their overloaded
equivalent functions do for
<a href="#4806">primitives</a>, sets, and attributes.</dd>

<dt>
<a NAME="5179"></a><a NAME="5180"></a><b><tt>sv_integer sv_set_list::flags()</tt></b></dt>

<dt>
<a NAME="5181"></a><a NAME="5182"></a><b><tt>void sv_set_list::reset_flags(sv_integer
i)</tt></b></dt>

<dt>
<a NAME="ab40"></a><b><tt>long sv_set_list::unique()</tt></b></dt>

<dl>
<dt>
returns<b> </b>the unique value for a set list like the equivalent function
for <a href="#ab13">primitives,</a> sets and attributes.</dt>
</dl>

<dt>
<a NAME="5183"></a><a NAME="5184"></a><b><tt>sv_set sv_set_list::set()</tt></b></dt>

<dd>
returns the first set in the list<b>.</b></dd>

<dt>
<a NAME="5185"></a><a NAME="5186"></a><b><tt>sv_integer sv_set_list::exists()</tt></b></dt>

<dd>
returns true if the list exists, false otherwise.</dd>

<dt>
<a NAME="5187"></a><a NAME="5188"></a><b><tt>sv_set_list sv_set_list::next()</tt></b></dt>

<dd>
returns the next item in the list. To get all the individual sets out of
a list, <tt>sl,</tt> you would write code like:</dd>

<dl>
<pre><tt><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b>sv_set_list temp = sl;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sv_set s;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(temp.exists())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s = temp.set();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Do whatever you want to do with individual
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // set s...

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = temp.next();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt></pre>
</dl>

<dt>
<a NAME="5189"></a><a NAME="5190"></a><b><tt>sv_integer sv_set_list::count()</tt></b></dt>

<dd>
returns a count of the number of sets in the list.</dd>

<dt>
<a NAME="5191"></a><a NAME="5192"></a><b><tt>sv_integer sv_set_list::contents()</tt></b></dt>

<dd>
returns the total of all the contents values for all the sets in a list.
Sets that are <tt>SV_EVERYTHING</tt> and <tt>SV_NOTHING</tt> both contribute
zero, so this is effectively a count of the number of primitives that go
to make up all the sets in the list.</dd>

<dt>
<a NAME="5193"></a><a NAME="5194"></a><b><tt>sv_set_list sv_set_list::prune(sv_box
b)</tt></b></dt>

<dd>
prunes each set in the list to the box using the set prune function, returning
a list of the resulting sets. Sets that are (or which become) <tt>SV_NOTHING</tt>
or <tt>SV_EVERYTHING</tt> will be retained.</dd>

<dt>
<a NAME="5195"></a><a NAME="5196"></a><a NAME="4195"></a><b><tt>sv_point
sv_set_list::point()</tt></b></dt>

<dd>
returns the characteristic point&nbsp; of a set list. This is defined to
be the point which minimizes the sum of squared distances to all the planes
that are in the sets' primitives' expressions. See the same function for
sets (page&nbsp;<a href="#SETPT"><img SRC="cross_ref_motif.gif" ALT="[*]" BORDER=1 height=10 width=10 align=BOTTOM></a>)
for a fuller explanation.</dd>

<dt>
<a NAME="5197"></a><a NAME="5198"></a><a NAME="4199"></a><a NAME="4200"></a><a NAME="4201"></a><a NAME="4202"></a><b><tt>sv_integer
sv_set_list::tag()</tt></b></dt>

<dd>
returns the unique svLis tag&nbsp; of lists of sets.</dd>

<dt>
<a NAME="5199"></a><a NAME="5200"></a><b><tt>sv_set_list sv_set_list::percolate()</tt></b></dt>

<dd>
returns a copy of the set list with all its sets' attributes copied down
to all the nodes that inherit them.</dd>

<dt>
<a NAME="ab42"></a><b><tt>sv_set_list sv_set_list::deep()</tt></b></dt>

<dd>
returns a deep copy of the set list.&nbsp; The user shouldn't normally
call this function.</dd>

<dt>
<a NAME="ab43"></a><b><tt>sv_integer sv_set_list::max_degree()</tt></b></dt>

<dd>
returns the maximum <a href="#4822">degree&nbsp;</a> out of all the primitives
in all the sets in the list.</dd>

<dt>
<a NAME="ab44"></a><b><tt>sv_integer sv_set_list::polygon_count()</tt></b></dt>

<dd>
returns the number of <a href="#5132">polygons</a> attached as <a href="#4979">attributes</a>
to all the <a href="#4972">sets</a> in the list.</dd>

<dt>
<a NAME="ab46"></a><b><tt>sv_set sv_set_list::unite()</tt></b></dt>

<dd>
returns a single set that is all the sets in the list unioned together.&nbsp;
See also the <tt><a href="#9105">list_products()</a></tt> function.</dd>

<dt>
<a NAME="ab46"></a><b><tt>sv_set sv_set_list::intersect()</tt></b></dt>

<dd>
returns a single set that is all the sets in the list intersected together.</dd>
</dl>
</dl>
<a NAME="4208"></a><a NAME="4209"></a>Two lists of sets are equal <tt>(sla
== slb)</tt>&nbsp; if their individual sets are equal with equal attributes
in any order.&nbsp;<a NAME="4211"></a><a NAME="4212"></a>The
<blockquote><tt>prim_op same(sv_set_list a, sv_set_list b)</tt></blockquote>
function returns <tt>SV_PLUS</tt> if the sets in the list are the same
in any order,
<tt>SV_COMP</tt> if <i>all</i> the sets in <tt>b</tt> are
complements of the corresponding sets in <tt>a</tt>, and <tt>SV_ZERO</tt>
otherwise. <i>The <tt>same</tt> function ignores attributes--it is only
concerned with geometry.</i>
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<h2>
<a NAME="SECTION009313000000000000000"></a><a NAME="5203"></a><a NAME="5204"></a><a NAME="5205"></a><a NAME="5206"></a><a NAME="5207"></a><a NAME="5208"></a><a NAME="MODELCLASS"></a><a NAME="4231"></a>The
<tt>sv_model</tt>
class</h2>
<i>Files:</i> <tt><font color="#FF0000">model.h</font>, model.cxx</tt>
<br>&nbsp;
<p>A model is a list of sets in a box. Models can be divided in two, making
two boxes that join in a plane perpendicular to one of the coordinate directions,
each of which contain a list of sets that is a <i>pruned</i> (that is,
simplified) version of the original list of sets in the original box. This
division is normally done recursively, leading to lots of little boxes
that fill the original big box in a binary tree, each little box containing
something very simple indeed (like <tt>SV_NOTHING</tt>, or the union of
just two leaf sets, or <tt>SV_EVERYTHING</tt> and so on). This recursive
division is the very heart of svLis, and is what makes the whole modeller
tractable and efficient.
<p><a NAME="5209"></a><a NAME="5210"></a><a NAME="5211"></a><a NAME="5212"></a>Fairly
obviously, it is possible to make a model&nbsp; from a set list and a box
by writing:
<blockquote>
<pre>sv_model m = sv_model(sv_set_list sl, sv_box b);</pre>
</blockquote>
<a NAME="5213"></a><a NAME="5214"></a>The list of sets is pruned to the
box using <tt><a href="#4948">prune()</a></tt>. The function
<blockquote><tt>sv_model(sv_set_list sl, sv_box b, LEAF_M)</tt></blockquote>
suppresses the pruning, and ensures that the model contains exactly
<tt>sl</tt>.
Most of the time, you'll probably only have one set in the list. C<font size=-1>++</font>
is smart enough to spot that there's a constructor for building a list
of sets from a single set, so you can say
<blockquote><tt>sv_model m = sv_model(sv_set s, sv_box b)</tt></blockquote>
in this case.&nbsp; There are also the following constructors for when
the model you create is part of a tree of models and you know the parent
node in the tree:
<blockquote><tt>sv_model(sv_set_list sl, sv_box b, sv_model parent)</tt>
<br><tt>sv_model(sv_set_list sl, sv_box b, LEAF_M, sv_model parent)</tt></blockquote>
Like the other `complicated' types, <tt>sv_model</tt> hides its data, and
functions are provided to get at it:
<dl>
<dl>
<dt>
<a NAME="5215"></a><a NAME="5216"></a><b><tt>void sv_model::set_flags(sv_integer
i)</tt></b></dt>

<dd>
and the following two functions work in exactly the same way as their overloaded
equivalent functions do for
<a href="#ab13">primitives</a>, sets, attributes,
and lists of sets.</dd>

<dt>
<a NAME="5217"></a><a NAME="5218"></a><b><tt>sv_integer sv_model::flags()</tt></b></dt>

<dt>
<a NAME="5219"></a><a NAME="5220"></a><b><tt>void sv_model::reset_flags(sv_integer
i)</tt></b></dt>

<dt>
<a NAME="5221"></a><a NAME="5222"></a><b><tt>sv_box sv_model::box()</tt></b></dt>

<dd>
returns the model's box.</dd>

<dt>
<a NAME="5223"></a><a NAME="5224"></a><b><tt>sv_set_list sv_model::set_list()</tt></b></dt>

<dd>
returns the model's set list.</dd>

<dt>
<a NAME="5225"></a><a NAME="5226"></a><b><tt>mod_kind sv_model::kind()</tt></b></dt>

<dd>
returns one of the four following codes: <tt>LEAF_M, X_DIV, Y_DIV,</tt>
or <tt>Z_DIV</tt>, meaning that the model is undivided, or divided in the
direction indicated.</dd>

<dt>
<a NAME="5227"></a><a NAME="5228"></a><b><tt>sv_real sv_model::coord()</tt></b></dt>

<dd>
returns the coordinate of the division plane for non-<tt>LEAF_M</tt> models.</dd>

<dt>
<a NAME="5229"></a><a NAME="5230"></a><a NAME="5231"></a><a NAME="5232"></a><b><tt>sv_model
sv_model::child_1()</tt></b></dt>

<dt>
<b><tt>sv_model sv_model::child_2()</tt></b></dt>

<dd>
return, for non-<tt>LEAF_M</tt> models, the two models into which the model
has been divided. The one with the most negative coordinates is the first
child.</dd>
</dl>

<dd>
<a NAME="ab50"></a><b><tt>sv_model sv_model::parent()</tt></b></dd>

<dl>
<dd>
return the parent of the model.&nbsp; For the root model of a tree the
model returned does not <tt>exists().</tt></dd>

<dt>
<a NAME="5233"></a><a NAME="5234"></a><b><tt>sv_integer sv_model::exists()</tt></b></dt>

<dd>
returns true if the model has been defined, false if not.</dd>

<dt>
<a NAME="5235"></a><a NAME="5236"></a><b><tt>prim_op same(sv_model a, sv_model
b)</tt></b></dt>

<dd>
calls the
<tt>same()</tt> functions for the model's <a href="#4211">set
list</a> and <a href="#3125">box</a>, and returns the appropriate result.</dd>

<dt>
<a NAME="5237"></a><a NAME="5238"></a><b><tt>mem_test sv_model::member(sv_point
p, sv_primitive known_surface[])</tt></b></dt>

<dl>
<dt>
membership tests the point against the model, assuming that all the sets
in its set list are unioned. The
<tt>known_surface[]
</tt>array contains
primitives for which the point is known to be on the surface. If there
are none such, send a pointer to an undefined primitive as the last argument.</dt>
</dl>

<dt>
<a NAME="5239"></a><a NAME="5240"></a><a NAME="4281"></a><b><tt>sv_point
sv_model::point()</tt></b></dt>

<dd>
returns the characteristic point&nbsp; of a model. This is, in fact, the
characteristic point of the model's <a href="#5195">set list</a>.</dd>

<dt>
<a NAME="5241"></a><a NAME="5242"></a><a NAME="4284"></a><a NAME="4285"></a><b><tt>sv_integer
sv_model::tag()</tt></b></dt>

<dd>
returns the unique svLis tag&nbsp; for models.</dd>

<dt>
<a NAME="ab60"></a><b><tt>long sv_model::unique()</tt></b></dt>

<dd>
returns the unique value for the model, like the similar function for <a href="#ab13">primitives</a>
etc.</dd>
</dl>

<dd>
<a NAME="ab101"></a><b><tt>sv_model sv_model::deep()</tt></b></dd>

<dl>
<dd>
returns a deep copy of the model.&nbsp; The user shouldn't normally call
this function.</dd>
</dl>
</dl>

<p><br>The following are functions that act on models:
<dl>
<dl>
<dt>
<a NAME="5243"></a><a NAME="5244"></a><b><tt>sv_model sv_model::divide(void
*vp, void decision(...) )</tt></b></dt>

<dd>
recursively divides a model employing a user-supplied decision procedure,
of which more in a moment. The pointer
<tt>vp</tt> is passed on to the
decision procedure to allow you to send in any data you like.</dd>

<dt>
<a NAME="5245"></a><a NAME="5246"></a><b><tt>sv_model sv_model::redivide(sv_set_list
sl, void *vp, void decision(...) )</tt></b></dt>

<dl>
<dt>
redivides an already-divided model. What for? Well, suppose that you create
a complicated model, then divide it. Then suppose you make a very small
change to the list of sets that the model holds (unioning a tiny cuboid
into one set in one corner, or something) and want to divide the result.
This redivide takes the new list of sets, <tt>sl,</tt> and your decision
procedure and only re-divides those parts of the model which have changed.
The model doesn't have to have been previously divided; if it hasn't redivide
puts <tt>sl </tt>in it and then divides from scratch.</dt>
</dl>

<dt>
<a NAME="5247"></a><a NAME="5248"></a><a NAME="4302"></a><b><tt>void sv_model::div_stat_report(ostream&amp;
f)</tt></b></dt>

<dd>
sends a report on all sorts of statistics about a divided model to <tt>f
</tt>(which
you usually want to be <tt>cout</tt>). This is useful for debugging divider
procedures.</dd>

<dt>
<a NAME="5249"></a><a NAME="5250"></a><b><tt>sv_box sv_model::tight_fit()</tt></b></dt>

<dl>tightfit computes
<i>an approximation</i> to the smallest enclosing
cuboid round the set(s) in a model. It does this by partially faceting
the model (see Page&nbsp;<a href="node9.html#FACETPIC"><img SRC="cross_ref_motif.gif" ALT="[*]" BORDER=1 height=10 width=10 align=BOTTOM></a>)
and returning the extremal coordinates of the facets.</dl>
</dl>

<p><br><a NAME="5251"></a><a NAME="5252"></a>The user-supplied divider
decision procedure&nbsp; mentioned above has the following form:
<br>&nbsp;
<dl>
<pre>void decision(sv_model m, sv_integer level, void *vp,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod_kind* k, sv_real* coord,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sv_model* c_1, sv_model* c_2)</pre>
</dl>
</dl>
This should decide whether to divide <tt>m</tt>. If <tt>m</tt> is not worth
dividing, <tt>*k</tt> should be set to <tt>LEAF_M</tt> on return. If <tt>m</tt>
should be divided, then <tt>k</tt> should be set to one of <tt>X_DIV, Y_DIV,</tt>
or <tt>Z_DIV</tt> to indicate which direction the model is to be divided
in, and <tt>*coord</tt> should be set to the coordinate value where the
split is to be (which must, obviously, be in the range specified by <tt>m</tt>'s
box). The value of <tt>level</tt> tells your
<tt>decision</tt> procedure
how far down the tree the division has got. The top (root) level is <tt>0</tt>,
and this is incremented for each level down.&nbsp;<a NAME="5253"></a><a NAME="5254"></a>There
is a
<dl>
<dt>
<tt>sv_model root_model();</tt></dt>
</dl>
function that your decision procedure can call to find out what the root
model was that is currently being divided. The pointer <tt>vp</tt> is the
pointer that you passed to <tt>divide(...)</tt> (or whichever); it allows
you to send in any data that you like, or indeed to retrieve any.
<p>It may well be the case that, in order to make this decision, your procedure
has to work out what the resulting children will be. If it does, it can
return either or both of them in <tt>*c_1</tt> and <tt>*c_2</tt>--this
will save <tt>divide</tt> the trouble of recomputing the information. If
it doesn't, it <i>must not</i> alter these pointers. If it decides that
the model is a leaf, but it is necessary to alter it anyway (for example
by faceting it), then it can return the new leaf model in <tt>*c_1</tt>.
<p><a NAME="5255"></a><a NAME="5256"></a>A rather na&iuml;ve decision procedure
is provided in the files <tt><font color="#FF0000">decision.h</font></tt>
and <tt><font color="#FF0000">decision.cxx</font></tt> called <tt>dumb_decision</tt>.
It is intended primarily as a template on which you can base your own divider
decision procedures, but to use it you write
<blockquote>
<pre>sv_model a = ....;
// ....
sv_model b = a.divide(0, &amp;dumb_decision);</pre>
</blockquote>
The procedure <tt>dumb_decision</tt>&nbsp; causes <tt>divide</tt> to split
the model in half recursively along the longest sides of boxes, until either
the sets in the boxes have a contents value less than the value returned
by&nbsp;<a NAME="LOWLIT"></a> <tt>sv_integer user_low_contents()<a NAME="5257"></a><a NAME="5258"></a></tt>&nbsp;
or the boxes have a volume lower than the one returned by <tt>sv_real user_little_box()<a NAME="5259"></a><a NAME="5260"></a></tt>.&nbsp;
Both these functions have to be provided by you; there are example ones
in the files <tt><font color="#FF0000">decision.h</font></tt> and <tt><font color="#FF0000">decision.cxx</font></tt>--see
these to find out how to alter these values. Reasonable values for <tt>user_low_contents()</tt>
to return are <tt>3</tt> or <tt>4</tt>, and <tt>0.001</tt> times the volume
of the undivided model box is okay for <tt>user_little_box()</tt>. Check
what sort of results you get with <tt>b.div_stat_report(cout)<a NAME="5261"></a><a NAME="5262"></a></tt>.
<p>There is also a <tt>smart_decision<a NAME="9100"></a></tt> procedure
which does divide look-ahead. You can set it up either to minimize the
maximum contents of the resulting divided boxes (tends to even out complexity)
or to minimize the minimum (tends to localize complexity). There are a
couple of procedures called
<blockquote><tt>set_smart_strategy(sv_integer s)</tt></blockquote>
and
<blockquote><tt>sv_integer get_smart_strategy()</tt></blockquote>
that select and return this if called before dividing commences. The value
of <tt>s</tt> should be one of
<tt>SV_MIN_MAX</tt> or <tt>SV_MIN_MIN</tt>.
<p>Be warned, it often turns out that the <tt>dumb_decision</tt> procedure
is smarter than the <tt>smart_decision</tt> one....&nbsp;&nbsp; Experiment.
<p><a NAME="5263"></a><a NAME="5264"></a><a NAME="5265"></a><a NAME="5266"></a>The
<tt>&lt;&lt;</tt>&nbsp;
and
<tt>>></tt>&nbsp; operators are defined for sending models to streams
and getting them back, and these work both for divided and for undivided
models, of course. However, there is little point in writing and reading
divided models as the model divider is faster than file access. It is always
quicker to write the undivided model, and to read that in and re-divide
it.
<p><a NAME="5267"></a><a NAME="5268"></a><a NAME="5269"></a><a NAME="5270"></a><a NAME="5271"></a><a NAME="5272"></a>When
models are split in two the resulting boxes are swollen by a factor to
ensure that no information falls down the cracks. The default factor is
<tt>DEF_SWELL_FAC</tt>
which is defined in <tt><font color="#FF0000">enum_def.h</font></tt> .
You can change the value (including setting it to 0; negative values are
not recommended....) by calling
<blockquote><tt>set_swell_fac(sv_real fac)</tt></blockquote>
where <tt>fac</tt> is the value you want. The function
<blockquote><tt>sv_real get_swell_fac()</tt></blockquote>
returns the current value.
<p><a NAME="ab100"></a>The svLis <tt>model</tt> class has a number of member
functions for graphics:
<dl>
<dl>
<dt>
<a NAME="5273"></a><a NAME="5274"></a><a NAME="FACETPIC"></a><b><tt>sv_model
sv_model::facet()</tt></b></dt>

<dd>
approximates the model by polygons, polylines, and points. These are stored
as attributes to the sets in the leaf boxes of the resulting divided model,
which is returned. Each set in the model's list of sets is faceted separately,
so the resulting facets will overlap in space if their parent sets in the
list do.&nbsp;<a NAME="5275"></a><a NAME="5276"></a><a NAME="5277"></a><a NAME="5278"></a>Faceting
is controlled by two tuning parameters. One sets the smallest box in the
division generated as a fraction of the original model box; this can be
controlled by a procedure:</dd>

<dl>
<dd>
<tt>void set_user_facet_fac(sv_real uf);</tt></dd>
</dl>

<dd>
the default value is 1, which allows division down to about 0.001 of the
original volume of the starting box; this is multiplied by the value of
uf that you provide. So, the bigger the value the coarser the division:
fine divisions take longer, but make better pictures. The other tuning
parameter sets how flat a curved primitive has to be in a box before it
is considered okay for becoming a facet in that box. The function is</dd>

<dl>
<dd>
<tt>void set_user_grad_fac(sv_real gf);</tt></dd>
</dl>

<dd>
again the default value is 1; this time larger values allow the range of
grad values for primitives to become larger and still be acceptable as
`flat', so increasing gf reduces faceting time but degrades the quality
of the facets, reducing it does the opposite.&nbsp; SvLis keeps track of
convex polyhedra (this is easy because they must always be an intersection
of planes) and facets these directly without further model division, for
efficiency.&nbsp; This means that if your model is a set list of convex
polyhedra it won't get divided at all by the <tt>facet()</tt> function,
and further that sub-models that contain only (parts of) convex polyhedra
won't be further divided..&nbsp; See the <a href="#ab500">polyhedron approximation
functions.</a></dd>

<dt>
<a NAME="5279"></a><a NAME="5280"></a><a NAME="4395"></a><b><tt>sv_model
sv_model::refacet(sv_set_list s)</tt></b></dt>

<dd>
calls the redivide function to re-facet an already faceted model that has
changed a small amount. The new set list is <tt>s.</tt></dd>

<dt>
<a NAME="5281"></a><a NAME="5282"></a><a NAME="4399"></a><b><tt>void plot_m_p_gons(sv_model
m, char* title)</tt></b></dt>

<dd>
plots a picture of a faceted model. You have to call facet() or refacet()
first. The charcter string is used as a window title. If you type <tt>?</tt>
in the graphics window <tt>plot_m_p_gons()</tt> creates, a list of commands
and other information is written to the console.&nbsp; You can also control
the plot by pressing the right mouse button in the graphics window, which
will cause a menu to appear.&nbsp; The left mouse button rotates the image
(drag and release to set it spinning), &lt;CTRL> left button (or the middle
button) translates the model,&nbsp; &lt;CTRL> middle (or left and middle)
zooms.</dd>

<dt>
<a NAME="5283"></a><a NAME="5284"></a><a NAME="4405"></a><b><tt>void plot_m_boxes(sv_model
m, sv_integer i, char* title)</tt></b></dt>

<dd>
plots a picture of the boxes in the divided model, <tt>m</tt>. The integer
<tt>i
</tt>can
take the following values:</dd>

<dl>
<dl>
<dt>
<tt>SV_NM_NE</tt></dt>

<dd>
plot only the boxes that aren't empty or solid;</dd>

<dt>
<tt>SV_NM_E</tt></dt>

<dd>
plot all the boxes;</dd>

<dt>
<tt>SV_M_NE</tt></dt>

<dd>
plot only the boxes that aren't empty or solid and facet the model and
plot that too;</dd>

<dt>
<tt>SV_M_E</tt></dt>

<dd>
plot all boxes, and facet the model and plot it;</dd>

<dd>
</dd>
</dl>
The boxes are colour-coded to indicate their contents: blue means empty,
cyan means one primitive, green means two, yellow three, and red four or
more. This procedure is mainly for debugging division decision procedures.&nbsp;
There is no point in calling it for a faceted model, as <tt>plot_m_p_gons()
</tt>has
a menu option to plot the <tt>facet()</tt>-generated boxes.</dl>

<dt>
<a NAME="5285"></a><a NAME="5286"></a><b><tt>int sv_model::has_polygons()</tt></b></dt>

<dd>
returns true if any of the sets in the model's set list have polygons attached
as attributes.&nbsp; Note that this does not walk the tree of a divided
model and tell you if any of the children have polygons. This function
is a much quicker function than...</dd>

<dt>
<a NAME="5287"></a><a NAME="5288"></a><b><tt>sv_integer sv_model::polygon_count()</tt></b></dt>

<dd>
returns a count of the number of polygons attached to all the sets in the
model.&nbsp; Note that this does not walk the tree of a divided model and
tell you if any of the children have polygons.</dd>
</dl>

<dd>
<a NAME="ab202"></a><b><tt>void sv_to_vrml(ostream&amp; os, sv_model m)</tt></b></dd>

<dd>
<b><tt>void sv_to_vrml(char* filename, sv_model m)</tt></b></dd>

<dl>
<dd>
writes a <i>faceted</i> model's polygons out in <a href="http://vrml.sgi.com/moving-worlds/spec">VRML</a>
format to the stream or file.</dd>
</dl>
<a NAME="RAYT"></a><a NAME="5289"></a><a NAME="5290"></a><a NAME="4417"></a><b><tt>sv_set
sv_model::fire_ray(sv_line ray, sv_real* hit_ray_param)</tt></b>
<dl>
<dl>performs ray-tracing into the model. The ray is the line <tt>ray</tt>.
The set returned is the leaf set containing the primitive which the ray
hits and <tt>hit_ray_param</tt> gives the parameter value where the hit
occurs. If the ray misses, an undefined set is returned (test for this
with the <tt>s.exists()</tt> function on Page&nbsp;<a href="node9.html#SETEX"><img SRC="cross_ref_motif.gif" ALT="[*]" BORDER=1 height=10 width=10 align=BOTTOM></a>).
If the ray interval starts out in air the first surface hit is returned;
if it starts in solid, the exit point is returned.&nbsp; If you want to
trace a ray with its origin at a point on a surface found by a previous
ray-tracing operation (for example to do shadows or reflections), then
move away from the surface by an epsilon (<tt>1.0e-4</tt> times the model
box's linear dimensions, say) to set the origin of the new ray. Otherwise
you'll merely get back the point you just found. . .</dl>

<dt>
<a NAME="5291"></a><a NAME="5292"></a><a NAME="4425"></a><b><tt>sv_set
sv_model::fire_ray(sv_line ray, sv_interval ray_param_interval, sv_real*
hit_ray_param)</tt></b></dt>

<dl>
<dt>
is just like the function above, but you can also specify the parametric
interval along the ray in which you are interested in an answer, <tt>ray_param_interval</tt>.</dt>
</dl>

<dt>
<a NAME="5293"></a><a NAME="5294"></a><a NAME="4429"></a><b><tt>sv_integer
generate_picture(sv_model m, view v, light_list_entry ll, sv_picture&amp;
pic, sv_real progress, void report_procedure(sv_real percent))</tt></b></dt>

<dl>This ray-traces a picture of divided model <tt>m</tt> into picture
<tt>pic
</tt>(see
page&nbsp;<a href="node9.html#PIC"><img SRC="cross_ref_motif.gif" ALT="[*]" BORDER=1 height=10 width=10 align=BOTTOM></a>
for a description of pictures, and how to save them to disc). The simple
divider decision procedure <tt><a href="#5256">dumb_decision(...)</a></tt>
in the file <tt><font color="#FF0000">decision.cxx</font></tt> is quite
good enough for generating divided models for this, though for very complicated
models you may care to reduce the smallest box size and increase the minimum
contents of leaf boxes a bit. Experiment.&nbsp; The view, <tt>v </tt>(see
page<a href="node9.html#VIEW"><img SRC="cross_ref_motif.gif" ALT="[*]" BORDER=1 height=10 width=10 align=BOTTOM></a>)
defines the viewpoint, viewing cone and so on, and <tt>ll </tt>defines
the lighting conditions (see page<a href="node9.html#LIGHT"><img SRC="cross_ref_motif.gif" ALT="[*]" BORDER=1 height=10 width=10 align=BOTTOM></a>).
Your procedure <tt>report_procedure()</tt> is called as the picture is
generated according to progress, which is a percentage. If you set progress
to 5%, say, then reporting will happen at 5% intervals. By using all the
facilities in the surface (page&nbsp;<a href="node9.html#SURFACE"><img SRC="cross_ref_motif.gif" ALT="[*]" BORDER=1 height=10 width=10 align=BOTTOM></a>),
view, and light_list_entry classes it is possible to generate near photo-realistic
pictures<a NAME="4445"></a>&nbsp; with svLis.</dl>

<dt>
<a NAME="5295"></a><a NAME="5296"></a><a NAME="4448"></a><b><tt>sv_integer
generate_picture(sv_model m, view v, light_list_entry ll, sv_picture&amp;
pic)</tt></b></dt>

<dd>
This is the same as the above function, but without the reporting.</dd>

<dt>
<a NAME="5297"></a><a NAME="5298"></a><a NAME="4451"></a><b><tt>sv_integer
generate_quickview_picture(sv_model m, view v, light_list_entry ll, sv_picture&amp;
pic, sv_real progress, void report_procedure(sv_real percent))</tt></b></dt>

<dl><font size=+0>this is the same as <tt>generate_picture()</tt>, but
in addition on Unix/X-Windows systems it forks the <tt>xv </tt>picture
viewer and raytraces the picture in gradually refining blocks, updating
the <tt>xv</tt> image as it goes. The effect is to make a very fast, but
crude pixellated image, which is gradually refined. This can be useful
for checking, as if, for example, you have set the wrong viewpoint, you
can abandon the generation of the picture quickly, reset it, then start
again. The finished picture takes rather longer to generate than g<tt>enerate_picture
</tt>would
take.</font></dl>
</dl>
</dl>

<h3>
<a NAME="SECTION00937000000000000000"></a><a NAME="5046"></a><a NAME="5047"></a><a NAME="SURF"></a><a NAME="5048"></a><a NAME="5049"></a><a NAME="5050"></a><a NAME="5051"></a><a NAME="SURFACE"></a><a NAME="3929"></a>The
<tt>sv_surface</tt>
class</h3>

<dl><i>Files:</i><tt><font color="#FF0000">surface.h, surface.cxx</font></tt>
<p>The <tt>sv_surface</tt> class&nbsp; is mainly used by the <a href="#RAYT">raytracer
</a>,
though the textures and colours it defines are also used by the <a href="#5281">polygon
renderer</a>.&nbsp; The <tt>sv_surface</tt> class allows diffuse and specular
colours to be assigned to the surface of a set, and many other things.
The class is user-extendable.
<p><a NAME="9103"></a>There is a large include file, <tt><font color="#FF0000">sv_cols.h</font></tt>,&nbsp;
that defines all the standard X-windows colour names with the prefix <tt>SV_</tt>
for you to use; thus it contains lines like:
<blockquote>&nbsp;
<br><tt>#define SV_OLD_LACE sv_point(0.992, 0.960, 0.901)</tt></blockquote>

<p><br>The <tt>sv_surface </tt>class has the folowing constructor and member
functions:
<br>&nbsp;
<dl>
<dt>
<a NAME="5052"></a><a NAME="5053"></a><b><tt>sv_surface s = sv_surface()</tt></b></dt>

<dl>
<dt>
makes a surface with default values (these are given with the member functions
below).</dt>
</dl>

<dt>
<a NAME="5054"></a><a NAME="5055"></a><b><tt>void sv_surface::diffuse_coeff(sv_real
c)</tt></b></dt>

<dd>
Sets the coefficient of diffuse reflectivity to <tt>c,</tt> which should
lie between 0 and 1. (Default value: 1.)</dd>

<dt>
<a NAME="5056"></a><a NAME="5057"></a><b><tt>void sv_surface::diffuse_colour(sv_point
col)</tt></b></dt>

<dd>
Sets the diffuse colour to <tt>col</tt>;
<tt>col.x
</tt>is the red value,
<tt>col.y</tt>
the green, and <tt>col.z
</tt>the blue. The values should lie between 0
and 1. (Default values: R = 0.5, G = 0.5, B = 0.5.)</dd>

<dt>
<a NAME="5058"></a><a NAME="5059"></a><b><tt>void sv_surface::specular_coeff(sv_real
c)</tt></b></dt>

<dd>
Sets the coefficient of specular reflectivity to <tt>c,</tt> which should
lie between 0 and 1. (Default value: 0.)&nbsp; The more specular a surface
is, the more it reflects.&nbsp; A value of 1 is a perfect mirror; take
care with 1: it may give an infinite hall-of-mirrors loop...</dd>

<dt>
<a NAME="5060"></a><a NAME="5061"></a><b><tt>void sv_surface::specular_power(sv_real
p)</tt></b></dt>

<dd>
Sets the specular exponent to <tt>p.</tt> The svLis raytracer uses the
standard cosine power-law to generate specular reflections: the higher
the value of <tt>p</tt>, the shinier the surface. (Default value: 1.)</dd>

<dt>
<a NAME="5062"></a><a NAME="5063"></a><b><tt>void sv_surface::specular_colour(sv_point
col)</tt></b></dt>

<dd>
Sets the specular colour cast to
<tt>col</tt>;
<tt>col.x
</tt>is the red
value, <tt>col.y</tt> the green, and <tt>col.z
</tt>the blue. The values
should lie between 0 and 1. (Default values: R = 0.5, G = 0.5, B = 0.5.)</dd>

<dt>
<a NAME="5068"></a><a NAME="5069"></a><b><tt>void sv_surface::shadow(int
i)</tt></b></dt>

<dd>
If <tt>i </tt>is true, the surface will have shadows cast upon it; if it
is false it won't (which is quicker to render). (Default value: false.)</dd>

<dt>
<a NAME="5070"></a><a NAME="5071"></a><b><tt>void sv_surface::mist(int
i)</tt></b></dt>

<dd>
If <tt>i </tt>is true, the surface will be attenuated in colour the further
away from the eye it is; if it is false it won't. Apart from the obvious
application of aerial perspective, you can create interesting effects by
making most of a model subject to mist except for a special feature that
you wish to highlight, which will then stand out clear. (Default value:
false.)</dd>

<dt>
<a NAME="5072"></a><a NAME="5073"></a><b><tt>void sv_surface::transmission(sv_real
t)</tt></b></dt>

<dd>
This sets the transmission of a transparent surface; a value of 0 makes
the surface opaque. Values should lie between 0 and 1. (Default value:
0.)</dd>

<dt>
<a NAME="5074"></a><a NAME="5075"></a><b><tt>void sv_surface::texture(sv_picture*
p)</tt></b></dt>

<dd>
This sets the texture map for the surface to the svLis picture pointed
to by p. See pages&nbsp;<a href="node9.html#PIC"><img SRC="cross_ref_motif.gif" ALT="[*]" BORDER=1 height=10 width=10 align=BOTTOM></a>
for details of pictures and&nbsp;<a href="node9.html#PMAP"><img SRC="cross_ref_motif.gif" ALT="[*]" BORDER=1 height=10 width=10 align=BOTTOM></a>
for the mapping function. (Default value: 0--null pointer means no picture.)</dd>

<dt>
<a NAME="5076"></a><a NAME="5077"></a><b><tt>void sv_surface::map_type(int
mt)</tt></b></dt>

<dd>
If <tt>mt </tt>is 1 the texture map will be repeatedly tiled into the surface,
if it is 0 there will only be one image of the map in the surface. (Default
value: 0)</dd>
</dl>

<dd>
<a NAME="ab30"></a><b><tt>void sv_surface::map_origin(sv_point p)</tt></b></dd>

<dl>
<dd>
The projection of <tt>p</tt> into the surface defines the bottom left-hand
corner of the texture.</dd>
</dl>

<dd>
<a NAME="ab31"></a><b><tt>void sv_surface::map_u(sv_point p)</tt></b></dd>

<dl>
<dd>
The projection of <tt>u</tt> into the surface defines the texture's horizontal
direction.</dd>
</dl>

<dd>
<a NAME="ab32"></a><b><tt>void sv_surface::map_size(sv_point p)</tt></b></dd>

<dl>
<dd>
The values of <tt>p.x </tt>and <tt>p.y</tt> define the size of the texture.
<tt>p.z</tt>
is not used.</dd>

<dt>
<a NAME="5078"></a><a NAME="5079"></a><b><tt>void sv_surface::map_0_xmit(int
zxmt)</tt></b></dt>

<dd>
If <tt>zxmt</tt> is true then black pixels in the texture map will make
the surface `underneath' transparent, if it is false then black will render
as black. This allows you, for example, to put a window-frame texture onto
a wall with the panes transparent. (Default value: false. )</dd>

<dt>
<a NAME="ab150"></a><b><tt>sv_integer sv_surface::tag()</tt></b></dt>

<dd>
returns the unique svLis tag&nbsp; for surfaces.</dd>
</dl>
</dl>
There are a corresponding series of <tt>sv_surface</tt> member functions
with no arguments and the names above that return the values, points and
so on set by those functions.
<p><a NAME="5080"></a><a NAME="5081"></a><a NAME="PMAP"></a>When the raytracer&nbsp;
and polygon plotters are rendering a svLis model that has texture-mapped
surfaces it&nbsp; makes calls to the user-modifiable function <tt>void
get_tex_map(...)</tt> that decides the map. This is in <font color="#FF0000"><tt>surface.cxx</tt>.</font>
Texture mappings are defined for planes and cylinders, for which the projection
is more-or-less obvious. You can add your own custom mappings for other
surfaces.
<br>&nbsp;
<br>&nbsp;
<dl>&nbsp;
<br>&nbsp;
<h2>
<a NAME="SECTION00938000000000000000"></a><a NAME="5083"></a><a NAME="5084"></a><a NAME="5085"></a><a NAME="5086"></a><a NAME="5087"></a><a NAME="5088"></a><a NAME="VIEW"></a>The
<tt>sv_view</tt>
class</h2>
<i>Files:</i> <tt><font color="#FF0000">view.h</font>, view.cxx</tt>
<br>&nbsp;
<p>The <tt>sv_view</tt> class is intended primarily for <a href="#RAYT">raytracing</a>.
You declare a variable of type <tt>sv_view</tt>, set values in it, then
pass it to the raytracer.
<p>The member functions are:
<br>&nbsp;
<dl>
<dt>
<a NAME="5089"></a><a NAME="5090"></a><b><tt>void sv_view::eye_point(sv_point
eye)</tt></b></dt>

<dd>
sets the position of the eye which is imagined to be viewing the picture.
(Default: [1,1,1])</dd>

<dt>
<a NAME="5091"></a><a NAME="5092"></a><b><tt>void sv_view::centre(sv_point
centre)</tt></b></dt>

<dd>
sets the point (not necessarily, but usually) in the model that is to be
at the centre of the view. (Default: [0,0,0])</dd>

<dt>
<a NAME="5093"></a><a NAME="5094"></a><b><tt>void sv_view::vertical_dir(sv_point
up)</tt></b></dt>

<dd>
sets the point that is to appear to be `up' from the centre. (Default:
[0,0,1])</dd>

<dt>
<a NAME="5095"></a><a NAME="5096"></a><b><tt>void sv_view::view_vector(sv_point
vv)</tt></b></dt>

<dd>
The eye position must be defined, but this is an alternative to <tt>centre()</tt>--it
defines which way you're looking. (Default: [-1,-1,-1])</dd>

<dt>
<a NAME="5097"></a><a NAME="5098"></a><b><tt>void sv_view::lens_angle(sv_real
angle)</tt></b></dt>

<dd>
This makes the difference between a telephoto lens and a wide angle. (Default:
0.646 radians, that is just less than 40<sup>o</sup>)</dd>

<dt>
<a NAME="ab151"></a><b><tt>sv_integer sv_view::tag()</tt></b></dt>

<dd>
returns the unique svLis tag&nbsp; for views.</dd>

<br>&nbsp;</dl>
There are also <tt>sv_view</tt> member functions with no arguments which
return these values once they have been set.
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<h2>
<a NAME="SECTION00939000000000000000"></a><a NAME="5100"></a><a NAME="5101"></a><a NAME="5102"></a><a NAME="5103"></a><a NAME="5104"></a><a NAME="5105"></a><a NAME="LIGHT"></a>The
<tt>sv_lightsource</tt>
and
<tt>sv_light_list
</tt>classes</h2>
<i>Files:</i> <tt><font color="#FF0000">light.h</font>, light.cxx</tt>
<br>&nbsp;
<p>The <tt>sv_lightsource</tt> class defines lights for <a href="#RAYT">raytracing
</a>.
It has the following member functions
<br>&nbsp;
<dl>
<dt>
<a NAME="5106"></a><a NAME="5107"></a><b><tt>void sv_lightsource::type(light_type
type)</tt></b></dt>

<dd>
sets the kind of light that this one is. There are two possibilities: PARALLEL
(the default) and POINT_SOURCE.</dd>

<dt>
<a NAME="5108"></a><a NAME="5109"></a><b><tt>void sv_lightsource::location(sv_point
location)</tt></b></dt>

<dd>
For point sources, this sets their position in space. (Default: [0,0,0])</dd>

<dt>
<a NAME="5110"></a><a NAME="5111"></a><b><tt>void sv_lightsource::colour(sv_point
colour)</tt></b></dt>

<dd>
sets the colour of the light; <tt>colour.x
</tt>is the red, <tt>colour.y</tt>
is the green, and <tt>colour.z</tt> is the blue; all must be between 0
and 1. (Default: [1,1,1])</dd>

<dt>
<a NAME="5112"></a><a NAME="5113"></a><b><tt>void sv_lightsource::direction(sv_point
direction)</tt></b></dt>

<dd>
sets the direction the light is pointing. (Default: [0,0,-1])</dd>

<dt>
<a NAME="5114"></a><a NAME="5115"></a><b><tt>void sv_lightsource::angle_power(sv_real
angle_power)</tt></b></dt>

<dd>
This sets the angle of the beam for a point source. (Default: 0.3 radians,
i.e. just under 20<sup>o</sup>)</dd>

<dt>
<a NAME="ab152"></a><b><tt>sv_integer sv_lightsource::tag()</tt></b></dt>

<dd>
returns the unique svLis tag&nbsp; for lightsources.</dd>
</dl>

<p><br>There are also <tt>sv_lightsource</tt> member functions with no
arguments which return these values once they have been set.
<p>In <tt>light.h</tt> a simple linked list class
<tt>sv_light_list</tt>
is defined which allows you to chain any number of light sources together--the
result is fed into the raytracer.
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<h3>
<a NAME="SECTION009310000000000000000"></a><a NAME="5117"></a><a NAME="5118"></a><a NAME="5119"></a><a NAME="5120"></a><a NAME="5121"></a><a NAME="5122"></a><a NAME="PIC"></a>The
<tt>sv_picture</tt>
class</h3>
<i>Files:</i> <tt><font color="#FF0000">picture.h</font>, picture.cxx</tt>
<p><font color="#993300">I</font><font color="#CC33CC">n the next release
of svLis (version 4) this structure will be included in the reference counting
scheme, and instances of it will consequently not be passed using pointers.</font>
<p>The <tt>sv_picture</tt> class is primarily internal to svLis--it stores
full RGB image bitmaps. It is used for textures in the surface class and
for building ray-trace-rendered images.
<p>The member and other functions are:
<br>&nbsp;
<dl>
<dt>
<a NAME="5123"></a><a NAME="5124"></a><b><tt>sv_picture* sv_read_image(char*
filename)</tt></b></dt>

<dt>
<b><tt>sv_picture* sv_read_image(istream&amp; is)</tt></b></dt>

<dd>
This reads a raw ppm-format or 24-bit bitmap (<tt>.bmp</tt>) image from
the file named
<tt>filename</tt> or from the stream into an <tt>sv_picture
</tt>and
returns a pointer to the result.&nbsp; The file-type is discovered automatically
from its contents.</dd>

<dt>
<b><tt>void sv_picture::resolution(sv_integer xr, sv_integer yr)</tt></b></dt>

<dl>
<dt>
sets the resolution to <tt>xr, yr </tt>if you create a picture for yourself.</dt>
</dl>

<dt>
<a NAME="5125"></a><a NAME="5126"></a><b><tt>sv_integer sv_picture::x_resolution()</tt></b></dt>

<dd>
Returns the number of pixels of a picture in the x direction.</dd>

<dt>
<a NAME="5127"></a><a NAME="5128"></a><b><tt>sv_integer sv_picture::y_resolution()</tt></b></dt>

<dd>
Returns the number of pixels of a picture in the y direction.</dd>
</dl>

<dd>
<b><tt>void sv_picture::pixel(sv_integer x, sv_integer y, sv_pixel p)</tt></b></dd>

<dl>
<dd>
sets the pixel (<tt>x, y</tt>) to <tt>p. </tt>The structure <tt>sv_pixel</tt>
is defined in <tt><font color="#FF0000">picture.h</font></tt>.&nbsp; If
you've created the picture (as opposed to svLis's creating it) you must
call <tt>resolution()</tt> first once.</dd>

<dt>
<a NAME="5129"></a><a NAME="5130"></a><b><tt>sv_pixel sv_picture::pixel(sv_integer
x, sv_integer y)</tt></b></dt>

<dd>
Returns the colour of a pixel.</dd>

<dt>
<b><tt>void image_type(sv_image_type itp)</tt></b></dt>

<dl>
<dt>
<tt>itp</tt> can be one of <tt>SV_PPM</tt> or <tt>SV_BMP</tt>.&nbsp; This
sets the image type for writing.&nbsp; On Microsoft Windows systems the
default is .<tt>bmp</tt> files, on all other systems it's raw <tt>.ppm</tt>
files.</dt>
</dl>

<dt>
<b><tt>void write_image(char* filename, sv_picture* pic, char* comment)</tt></b></dt>

<dt>
<b><tt>void write_image(ostream&amp; os, sv_picture* pic, char* comment)</tt></b></dt>

<dl>
<dt>
writes the picture in the preset format to the file or stream.</dt>
</dl>

<dt>
<a NAME="ab153"></a><b><tt>sv_integer sv_picture::tag()</tt></b></dt>

<dl>
<dt>
returns the unique svLis tag&nbsp; for pictures.</dt>
</dl>
</dl>
</dl>
There's a constructor for the <tt>sv_pixel</tt> <tt>struct</tt> that builds
it from an <tt>sv_point</tt>:
<br>&nbsp;
<dd>
<tt>sv_pixel p = sv_pixel(sv_point(red, green, blue));</tt></dd>

<br>&nbsp;
<p>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<p>The <tt>red, green</tt> and <tt>blue</tt> values are <tt>sv_reals</tt>
in the range [0, 1].&nbsp; The members of <tt>sv_pixel </tt>are called
<tt>r,g,</tt>
and <tt>b.</tt>&nbsp; They are of type <tt>GLubyte</tt>, which is an OpenGL
definition for&nbsp; <tt>unsigned char.&nbsp; </tt>There is also a function
to turn a pixel back into a point colour value:
<br>&nbsp;
<blockquote><tt>sv_point sv_pixel::point();</tt></blockquote>

<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<h2>
<a NAME="SECTION009311000000000000000"></a><a NAME="5132"></a><a NAME="5133"></a><a NAME="5134"></a><a NAME="5135"></a><a NAME="5136"></a><a NAME="5137"></a><a NAME="5138"></a><a NAME="5139"></a><a NAME="POLYGON"></a><a NAME="4099"></a>The
<tt>sv_p_gon</tt>
struct</h2>
<i>Files:</i> <tt><font color="#FF0000">polygon.h</font>, polygon.cxx</tt>
<p><font color="#993300">I</font><font color="#CC33CC">n the next release
of svLis (version 4) this structure will be included in the reference counting
scheme, and instances of it will consequently not be passed using pointers.</font>
<p>A single polygon&nbsp; can represent a three-dimensional point-set<a NAME="4100"></a>
, a polyline<a NAME="4101"></a> , or (naturally) a polygon. It consists
of a linked list of points in space that usually, though not necessarily,
lie in a plane. Polygons are used to approximate svLis models mainly for
producing graphics.
<p>Here are the data of the polygon structure:
<blockquote>
<pre>struct sv_p_gon
{
&nbsp; sv_point p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The point
&nbsp; sv_point g;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The grad at that point
&nbsp; sv_p_gon* next;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Link to the next one
&nbsp; sv_integer flag;&nbsp; // used for clipping
&nbsp; sv_p_gon_kind kind;&nbsp; // What it is</pre>

<pre>// Plus member functions ....</pre>

<pre>}</pre>
</blockquote>
The value of <tt>kind</tt> can be one of <tt>PT_SET, P_LINE</tt>, or <tt>P_GON</tt>.
These represent point sets, poly-lines, and polygons respectively. A polygon
always forms a closed loop (i.e. successive values of <tt>next</tt> chain
back to the start), even if it's really a polyline (in which case the last
<tt>next</tt>
is ignored), or a point set.
<p>A number of functions are provided for dealing with polygons:
<br>&nbsp;
<dl>
<dl>
<dt>
<a NAME="5140"></a><a NAME="5141"></a><b><tt>sv_p_gon* first_point(sv_point
q, sv_p_gon_kind k)</tt></b></dt>

<dd>
creates a new polygon of the appropriate kind containing a single point.</dd>

<dt>
<a NAME="5142"></a><a NAME="5143"></a><b><tt>sv_p_gon* add_edge(sv_p_gon*
pg, sv_point q)</tt></b></dt>

<dd>
adds a point in the linked list after
<tt>pg</tt>. The pointer returned
is to the new point.</dd>

<dt>
<a NAME="5144"></a><a NAME="5145"></a><b><tt>sv_integer p_gon_vertex_count(sv_p_gon*
pg)</tt></b></dt>

<dd>
returns the number of vertices in a polygon<b>.</b></dd>

<dt>
<a NAME="5146"></a><a NAME="5147"></a><b><tt>void set_p_gon_grad(sv_p_gon*
pg, sv_primitive p)</tt></b></dt>

<dd>
sets values of <tt>g </tt>for all the points in the polygon to a normalized
grad vector to the primitive at that point. Displays and software that
use Gouraud shading to depict curved surfaces can use this information
to render the polygon.</dd>

<dt>
<a NAME="5148"></a><a NAME="5149"></a><b><tt>void kill_p_gon(sv_p_gon*
pg)</tt></b></dt>

<dd>
returns the storage reserved for a polygon to the free space.</dd>

<dt>
<a NAME="5150"></a><a NAME="5151"></a><b><tt>sv_p_gon* copy_p_gon(sv_p_gon*
pg)</tt></b></dt>

<dd>
returns a copy of a polygon.</dd>

<dt>
<a NAME="5152"></a><a NAME="5153"></a><b><tt>sv_p_gon* copy_p_gon(sv_p_gon*
pg, sv_p_gon_kind k)</tt></b></dt>

<dd>
returns a copy of a polygon with its kind changed to k.</dd>

<dt>
<a NAME="5154"></a><a NAME="5155"></a><b><tt>sv_point p_gon_tri_norm(sv_p_gon*
pg)</tt></b></dt>

<dd>
cycles through all the triangles that make up a polygon, adding up the
vector product of their edges, which is returned. This is a sort of mean
normal direction for the polygon, but, more importantly. . .</dd>

<dt>
<a NAME="5156"></a><a NAME="5157"></a><b><tt>sv_real p_gon_area(sv_p_gon*
pg)</tt></b></dt>

<dd>
uses the above function to compute the polygon's area. The calculation
is exact if the polygon is planar, approximate otherwise.</dd>

<dt>
<a NAME="5158"></a><a NAME="5159"></a><a NAME="4131"></a><a NAME="4132"></a><b><tt>sv_integer
sv_p_gon::tag()</tt></b></dt>

<dl>returns the unique svLis tag&nbsp; for polygons.</dl>
</dl>
</dl>

<h3>
<a NAME="ab300"></a>Voronoi diagrams</h3>
<i>Files: </i><tt><font color="#FF0000">voronoi.h</font>, voronoi.cxx</tt>
<p><font color="#CC33CC">In the next release of svLis (version 4) these
structures will be included in the reference counting scheme, and instances
of them will consequently not be passed using pointers.</font>
<p>This is not the place to describe in detail what a Voronoi diagram and
its associated structure a Delaunay triangulation are, but you may care
to consult <a href="node10.html#ab10">this reference</a>.&nbsp; Neither
are either of these structures a central part of svLis.&nbsp; However,
facilities for computing them have been added to svLis as a precursor to
the computation of medial-axis transforms and finite-element meshes.&nbsp;
SvLis uses three data structures for Voronoi diagrams: a Delaunay structure
that represents the points in the diagram, a vertex structure that represents
an individual vertex in the diagram, and a Voronoi structure that represents
the whole diagram.&nbsp; These are best explained in reverse order.
<br>&nbsp;
<br>&nbsp;
<p><b>The <tt>sv_voronoi</tt> class</b>
<br>&nbsp;
<dl>
<dl>
<dt>
<b><tt>sv_voronoi::sv_voronoi()</tt></b></dt>

<dl>
<dt>
constructor to initialize a null Voronoi diagram.</dt>
</dl>

<dt>
<b><tt>sv_voronoi::sv_voronoi(sv_box bb);</tt></b></dt>

<dl>
<dt>
constructor to initialize an empty Voronoi diagram.&nbsp; All the subsequent
points to be inserted in it will be in the box.</dt>
</dl>

<dt>
<b><tt>sv_delaunay* sv_voronoi::add_point(sv_point p);</tt></b></dt>

<dl>
<dt>
Add a point to a Voronoi diagram and return a pointer to the Delaunay structure
that contains it.</dt>
</dl>

<dt>
<b><tt>sv_vertex* sv_voronoi::walk_start()</tt></b></dt>

<dl>
<dt>
Return the start vertex for recursive walks. This will always be a vertex
of the last inserted point. Use it but don't save it - it may be deleted
by subsequent point insertions.</dt>
</dl>

<dt>
<b><tt>sv_integer sv_voronoi::point_count()</tt></b></dt>

<dl>
<dt>
Return the total number of points in the structure.</dt>
</dl>

<dt>
<b><tt>sv_box sv_voronoi::box()</tt></b></dt>

<dl>
<dt>
Return the initial box.</dt>
</dl>

<dt>
<b><tt>sv_delaunay* sv_voronoi::nearest(sv_point p);</tt></b></dt>

<dl>
<dt>
Return the nearest neighbour of the point (that is the Delaunay point in
whos territory the point lies).</dt>
</dl>

<dt>
<b><tt>sv_delaunay* sv_voronoi::neighbours(sv_delaunay* d);</tt></b></dt>

<dl>
<dt>
Return a linked list which contains all the Voronoi neighbours of a Delaunay
point.</dt>
</dl>

<dt>
<b><tt>sv_vertex* sv_voronoi::territory(sv_delaunay* d)</tt></b></dt>

<dl>
<dt>
Return a linked list which contains all the vertices of a Delaunay point's
territory</dt>
</dl>

<dt>
<b><tt>sv_vertex* sv_voronoi::contiguity(sv_delaunay* d0, sv_delaunay*
d1)</tt></b></dt>

<dl>
<dt>
Return a linked list which contains all the vertices common to two neighbouring
Delaunay points.</dt>
</dl>

<dt>
<b><tt>int sv_voronoi::exists()</tt></b></dt>

<dl>
<dt>
false for a null Voronoi diagram, true for a defined one.</dt>
</dl>

<dt>
<b><tt>sv_integer sv_voronoi::tag()</tt></b></dt>

<dl>
<dt>
Unique svLis tag for Voronoi diagrams.</dt>
</dl>

<dt>
<b><tt>void sv_voronoi::write(ostream&amp;)</tt></b></dt>

<dl>
<dt>
Print the data to a stream; primarily for diagnostic purposes.</dt>
</dl>

<dt>
<b><tt>sv_voronoi tet_mesh(sv_model m, sv_real d)</tt></b></dt>

<dl>
<dt>
Generates a mesh of Delaunay tetrahedra that fill the solid part(s) of
model <tt>m.</tt>&nbsp; The mean distance between Delaunay neighbours will
be (roughly) <tt>d.</tt></dt>
</dl>

<dt>
<b><tt>void plot_voronoi(sv_voronoi v, char* title, sv_integer pv, sv_integer
pd, sv_integer pp, sv_real tet_fac)</tt></b></dt>

<dt>
<b><tt>void plot_voronoi(sv_voronoi v)</tt></b></dt>

<dl>
<dt>
Generates a picture of Voronoi diagram <tt>v.</tt>&nbsp; The integers <tt>pv,
pd, </tt>and <tt>pp</tt> are logical variables that switch on the plotting
of the Voronoi territories, the Delaunay tetrahedra, and the data points
respectively (though you can switch all these on and off from a menu in
the plot window too).&nbsp; The value of <tt>tet_fac </tt>decided a shrinkage
to apply to the tetrahedra, which sometimes makes it easier to see what's
going on.&nbsp; Values of about 0.8 are sensible.&nbsp; The second function
does just the same but makes up sensible defaults.</dt>
</dl>

<dt>
</dt>
</dl>
</dl>
<b>The <tt>sv_vertex</tt> class</b>
<p>A Voronoi vertex is the circumcentre of a Delaunay tetrahedron.
<dl>
<dl>
<dt>
<b><tt>void sv_vertex::set_flag(sv_integer f)</tt></b></dt>

<dt>
<b><tt>void sv_vertex::reset_flag(sv_integer f)</tt></b></dt>

<dt>
<b><tt>sv_integer sv_vertex::flag()</tt></b></dt>

<dl>
<dt>
Set, reset and return flags.</dt>
</dl>

<dt>
<b><tt>sv_delaunay* sv_vertex::delaunay(sv_integer i)</tt></b></dt>

<dl>
<dt>
Returns Delaunay point <tt>i </tt>round the vertex - one of the corners
of the vertex's Delaunay tetrahedron.&nbsp; The value of <tt>i </tt>can
lie in the range 0...3.</dt>
</dl>

<dt>
<b><tt>sv_vertex* sv_vertex::neighbour(sv_integer i)</tt></b></dt>

<dl>
<dt>
Returns vertex neighbour <tt>i </tt>of this vertex.&nbsp; The value of
<tt>i
</tt>can
lie in the range 0...3.&nbsp; Each vertex is topologically oposite its
corresponding Delaunay point, and the line joining it to this vertex is
the center of the axis of the cylinder defined by the other three Delaunay
points of the four.&nbsp;&nbsp; Note, the vertex returned may be at infinity.</dt>
</dl>

<dt>
<b><tt>sv_point sv_vertex::position()</tt></b></dt>

<dl>
<dt>
Returns the co-ordinates of the circumcentre of the Delaunay tetrahedron.</dt>
</dl>

<dt>
<b><tt>sv_real sv_vertex::r_squared()</tt></b></dt>

<dl>
<dt>
Returns the squared radius of the circumsphere of the Delaunay tetrahedron.</dt>
</dl>

<dt>
<b><tt>sv_point sv_vertex::centroid()</tt></b></dt>

<dl>
<dt>
Returns the centroid of the Delaunay tetrahedron.</dt>
</dl>

<dt>
<b><tt>sv_vertex* sv_vertex::next()</tt></b></dt>

<dl>
<dt>
Next entry in a linked list of vertices.</dt>
</dl>

<dt>
<b><tt>int sv_vertex::infinity()</tt></b></dt>

<dl>
<dt>
Return trueif this vertex is at infinity.</dt>
</dl>

<dt>
<b><tt>sv_integer sv_vertex::tag()</tt></b></dt>

<dl>
<dt>
Unique svLis tag for vertices.</dt>
</dl>

<dt>
<b><tt>sv_vertex* find_enclosing_tet(sv_vertex* v, sv_point p);</tt></b></dt>

<dl>
<dt>
Find the tetrahedron that contains the point, starting the walk to search
for it at vertex v.</dt>
</dl>

<dt>
<b><tt>void reset_flags(sv_vertex* v, sv_integer f);</tt></b></dt>

<dl>
<dt>
Walk vertices resetting flag bits that are one in <tt>f.</tt></dt>
</dl>

<dt>
<b><tt>sv_real tet_vol(sv_point k, sv_pointl, sv_point m, sv_point n)</tt></b></dt>

<dl>
<dt>
Compute the signed volume determinant of a tetrahedron formed by the four
points.&nbsp; For the actual volume take <tt>abs(tet_vol(...))/6</tt>.</dt>
</dl>
</dl>
</dl>

<dl>&nbsp;
<p><b>The <tt>sv_delaunay</tt> class</b>
<p>This class holds the individual points that form the basis of the Voronoi
diagram.
<br>&nbsp;
<dl>
<dt>
<b><tt>void sv_delaunay::set_flag(sv_integer f)</tt></b></dt>

<dt>
<b><tt>void sv_delaunay::reset_flag(sv_integer f)</tt></b></dt>

<dt>
<b><tt>sv_integer sv_delaunay::flag()</tt></b></dt>

<dl>
<dt>
these work in the same way as the flags for other svLis classes.</dt>
</dl>

<dt>
<b><tt>sv_point sv_delaunay::point()</tt></b></dt>

<dl>
<dt>
returns the associated point.</dt>
</dl>

<dt>
<b><tt>void sv_delaunay::set(sv_set s)</tt></b></dt>

<dt>
<b><tt>sv_set sv_delaunay::set()</tt></b></dt>

<dl>
<dt>
set and return the set associated with the Delaunay point.</dt>
</dl>

<dt>
<b><tt>void sv_delaunay::model(sv_model m)</tt></b></dt>

<dt>
<b><tt>sv_model sv_delaunay::model()</tt></b></dt>

<dl>
<dt>
set and return the model associated with the Delaunay point.</dt>
</dl>

<dt>
<b><tt>sv_delaunay* sv_delaunay::next()</tt></b></dt>

<dl>
<dt>
return the next point when they form a linked list.</dt>
</dl>

<dt>
<b><tt>int sv_delaunay::c_hull()</tt></b></dt>

<dl>
<dt>
returns true if this point is on the convex hull, false otherwise.</dt>
</dl>

<dt>
<b><tt>sv_integer sv_delaunay::tag()</tt></b></dt>

<dl>
<dt>
returns the svLis tag for Delaunay points.</dt>
</dl>
</dl>

<br>&nbsp;
<h1>
<a NAME="SECTION00940000000000000000"></a><a NAME="4458"></a><a NAME="5299"></a><a NAME="5300"></a><a NAME="5301"></a><a NAME="5302"></a><a NAME="UTILS"></a>Utilities</h1>
<i>Files:</i> <tt><font color="#FF0000">sv_util.h, sv_util.cxx</font></tt>
<br>&nbsp;
<p>The svLis utilities are intended to be user-extendible, but a number
are supplied as standard. They are:
<br>&nbsp;
<dl>
<dt>
<a NAME="5303"></a><a NAME="5304"></a><a NAME="4471"></a><a NAME="4472"></a><a NAME="4473"></a><a NAME="4474"></a><b><tt>void
integral(sv_model m, sv_real accy, sv_real&amp; vol, sv_point&amp; centroid,
sv_point&amp; mxyz, sv_point&amp; nxyz)</tt></b></dt>

<dl>
<dt>
This procedure computes the volume of the model, <tt>m </tt>(which must
be a divided model), along with the position of its centroid, its three
radii of gyration, <tt>mxyz,</tt> and its product moments, <tt>nxyz</tt>,
about the centroid in the coordinate directions. The value of <tt>accy</tt>
decides the accuracy of the volume calculation; the value of vol returned
should be within <tt>accy </tt>of the true value with 95% confidence. A
sensible value to choose might be 0.01--the lower the value of <tt>accy,</tt>
the longer the calculation takes. For accuracy, you should call <tt><a href="#5267">set_swell_fac(0)</a></tt>
before dividing the model. The calculations are done exactly on divided
model boxes that are all solid or all air, and using a Monte Carlo technique
on boxes containing surfaces.</dt>
</dl>

<dt>
<a NAME="5305"></a><a NAME="5306"></a><a NAME="4484"></a><b><tt>sv_real
area(sv_model m)</tt></b></dt>

<dd>
This procedure computes the surface area of the model, <tt>m</tt>, which
must be a faceted model. It adds up the area of the facets. For accuracy,
you should call <tt>set_swell_fac(0)</tt> before faceting the model.</dd>

<dt>
<b><tt>sv_real area(sv_model m, sv_set a)</tt></b></dt>

<dd>
This procedure computes the surface area that the set <tt>s</tt> contributes
to the model, <tt>m</tt>, which must be a faceted model. It adds up the
area of the facets. For accuracy, you should call <tt>set_swell_fac(0)</tt>
before faceting the model.</dd>

<dt>
<a NAME="5307"></a><a NAME="5308"></a><b><tt>sv_point ran_point(sv_box
b)</tt></b></dt>

<dd>
This generates a random point from the uniform distribution over the box.</dd>

<dt>
<a NAME="5309"></a><a NAME="5310"></a><b><tt>sv_interval dist_2(sv_box
a, sv_box b)</tt></b></dt>

<dd>
This computes the interval representing the minimum and maximum squared
distance between the two boxes. If the boxes overlap, the minimum is 0,
of course. The function returns the value of the closest two points--one
in each box--could get to each other, and the value when they are furthest
apart.</dd>

<dt>
<a NAME="5311"></a><a NAME="5312"></a><b><tt>sv_point newton(sv_primitive
p, sv_point start, sv_real accy)</tt></b></dt>

<dd>
This finds a point on the surface of the primitive using Newton-Raphson
from point
<tt>start.</tt> The value given in <tt>accy </tt>determines
how finely the iteration runs.</dd>

<dt>
<a NAME="ab7590"></a><b><tt>sv_point newton(sv_set s, sv_point start, sv_real
accy)</tt></b></dt>

<dl>
<dt>
This uses the set's <a href="#ab7589">grad</a> function to find a point
on the set's surface, just like the above function for primitives.</dt>
</dl>

<dt>
<a NAME="5313"></a><a NAME="5314"></a><b><tt>sv_point edge(sv_set s, sv_point
start, sv_real accy)</tt></b></dt>

<dd>
This finds a point on the edge formed by the intersection or union of two
leaf sets using Newton-Raphson from point start. The value given in <tt>accy
</tt>determines
how finely the iteration runs. Clearly <tt>s</tt> must be the union or
intersection of two leaf sets.</dd>

<dt>
<a NAME="5315"></a><a NAME="5316"></a><b><tt>sv_point edge_step(sv_set
s, sv_point start, sv_point d, sv_real r, sv_real accy)</tt></b></dt>

<dd>
This moves (roughly) distance <tt>r </tt>along the edge formed by the intersection
or union of two leaf sets in (roughly) direction <tt>d </tt>using Newton-Raphson
from point <tt>start [</tt>found by procedure <tt>edge(...)]</tt>. The
value given in <tt>accy </tt>determines how finely the iteration runs.
Clearly
<tt>s </tt>must be the union or intersection of two leaf sets.</dd>

<dt>
<a NAME="5317"></a><a NAME="5318"></a><b><tt>sv_point corner(sv_set s,
sv_point start, sv_real accy)</tt></b></dt>

<dd>
This finds the point of the corner formed by the intersection and/or union
of three leaf sets using Newton-Raphson from point <tt>start.</tt> The
value given in <tt>accy </tt>determines how finely the iteration runs.
Clearly <tt>s </tt>must be a set-theoretic expression involving three leaf
sets.</dd>

<dt>
<a NAME="5319"></a><a NAME="5320"></a><b><tt>sv_point binary_chop(sv_primitive
p, sv_point p0, sv_real v0, sv_point p1, sv_real v1, sv_real accy)</tt></b></dt>

<dd>
This finds a zero of the primitive along the line between the two points
<tt>p0</tt>
and
<tt>p1</tt>. The value of <tt>v0</tt> should be <tt>p.value(p0)</tt>
and
<tt>v1</tt> should be <tt>p.value(p1)</tt>--clearly
<tt>v0</tt> and
<tt>v1</tt>
should have opposite signs. The reason for requiring these values as arguments
is that you almost always have to work them out before calling the procedure
anyway, so your providing the results saves time. The value given in <tt>accy</tt>
determines how finely the iteration runs. This procedure uses a binary
chop (as its name implies) rather than Newton-Raphson, as this guarantees
that the result will always lie between the two input points.</dd>

<dt>
<a NAME="5321"></a><a NAME="5322"></a><b><tt>sv_plane box_face(sv_box b,
sv_integer i)</tt></b></dt>

<dd>
returns the
<tt>i</tt>th face of the box as a plane. The value of <tt>i
</tt>should
be between 0 and 5 inclusive.</dd>

<dt>
<a NAME="5323"></a><a NAME="5324"></a><b><tt>sv_set wireframe_box(sv_box
b)</tt></b></dt>

<dd>
This constructs a set which is a wireframe representation of box <tt>b</tt>.</dd>

<dt>
<a NAME="5325"></a><a NAME="5326"></a><b><tt>sv_real crinkliness(sv_model
m)</tt></b></dt>

<dl>This returns the crinkliness of a faceted model <tt>m </tt>(set swell
to 0 as for area). Crinkliness is defined as the surface area of the model
divided by the surface area of the sphere with the same volume as the model.
The smallest possible value is 1; bigger values indicate how unlike a table-tennis
ball the model is, and how like a starfish...</dl>

<dt>
<a NAME="ab278"></a><b><tt>sv_primitive slice(sv_plane f, sv_mod_kind k,
sv_real d)</tt></b></dt>

<dt>
<b><tt>sv_primitive slice(sv_primitive p, sv_mod_kind k, sv_real d)</tt></b></dt>

<dt>
<b><tt>sv_set slice(sv_set s, sv_mod_kind k, sv_real d)</tt></b></dt>

<dt>
<b><tt>sv_set_list slice(sv_set_list sl, sv_mod_kind k, sv_real d)</tt></b></dt>

<dt>
<b><tt>sv_box slice(sv_box b, sv_mod_kind k, sv_real d)</tt></b></dt>

<dt>
<b><tt>sv_model slice(sv_model m, sv_mod_kind k, sv_real d)</tt></b></dt>

<dl>These six functions create a two-dimensional slice of their argument.&nbsp;
The value of <tt>k </tt>can be one of&nbsp; <tt>X_DIV, Y_DIV</tt>, or <tt>Z_DIV</tt>
-- this is the dimension that gets removed.&nbsp; The value of d is the
value of that dimension where the slice is taken.&nbsp; Note that slicing
a plane returns a primitive.&nbsp; These functions effectively create an
extrusion of the cross-section of an object.&nbsp; As all svLis entities
(except models) can be rotated and translated the cross section can effectively
be anywhere.</dl>
<a NAME="ab500"></a><b><tt>sv_set poly_cylinder(sv_line axis, sv_real r)</tt></b>
<br><b><tt>sv_set poly_cone(sv_line axis, sv_real r)</tt></b>
<br><b><tt>sv_set poly_sphere(sv_point centre, sv_real r)</tt></b>
<dl>These three functions create polyhedral approximations to the true
primitives described <a href="#4842">here</a>.&nbsp; Their value is that&nbsp;
the model faceter is very efficient at faceting convex polyhedra because
it's such an easy problem, so these give a fast way of trying out crude
models.&nbsp; Intersecting any of these shapes together, and intersecting
any with other planes (and cuboids), retains their convexity, of course,
and the corresponding speed will still be high.&nbsp; A particularly effective
strategy is to make set lists of convex polyhedra to form their union,
rather like the <tt><a href="#9105">list_products()</a></tt> function.&nbsp;
This gives the fastest rendering of all, though the shapes have (parts
of) hidden polygons of other shapes internally then of course.</dl>
<a NAME="ab279"></a><b><tt>void polygon_faces(sv_integer fc)</tt></b>
<br><b><tt>sv_integer polygon_faces()</tt></b>
<dl>These functions set and return the number of facets used to approximate
a polygon for the above three functions.</dl>
<a NAME="ab280"></a><b><tt>void polygon_approximation(sv_real accuracy)</tt></b>
<br><b><tt>sv_sv_real polygon_approximation()</tt></b>
<dl>If you set the number of polygon faces to 0 with the above function,
then you will get a polygon that is never more than accuracy away from
a circle; that is to say that the two circles enclosing the polygon will
be no more than <tt>accuracy*radius</tt> appart.</dl>
</dl>

<br>&nbsp;
<p>If you write a new utility that you think would be helpful to other
svLis users, email <tt>svlis@bath.ac.uk</tt> with a brief description of
it and we may include it in the next release.
<h1>
<a NAME="SECTION00950000000000000000"></a><a NAME="4538"></a><a NAME="TESTP"></a><a NAME="ab900"></a>SvLis
programs</h1>
There are a number of programs provided with svLis.&nbsp; Their sources
are in the directory <tt>programs</tt> under the main svLis directory,
which has the following structure:
<br>&nbsp;
<dl>
<dl><tt>programs--</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |-README</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |-refinery--</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|-src--</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|-refinery.cxx</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |-sv_edit--</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|-src--</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|-sv_edit.cxx</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|-edittool.cxx</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |-tst_prgs--</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|-expt.cxx</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|-sv_convert.cxx</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|-sv_display.cxx</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|-sv_tst_1.cxx</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|-sv_tst_2.cxx</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|-voronoi_tst.cxx</tt></dl>
</dl>
The file <tt>README</tt> just gives information on what is in the <tt>programs</tt>
directory.&nbsp; Each architecture supported by svLis has a mechanism provided
in the distribution for creating executables from all the other programs.&nbsp;
For Unix systems, just typing make will create executables for them all
(it will also build the user library too); for Microsoft Windows installations
there are Visual C++ project files for all the programs in the subdirectories
of the <tt>projects</tt> directory; for Apple Macs there is a project file
supplied to build all these programs (and a separate one for the user library).&nbsp;
All the executables are placed in the <tt>bin</tt> directory under the
main svLis directory.
<p>This is what all the programs do:
<br>&nbsp;
<br>&nbsp;
<dl><b><tt>sv_tst_1</tt></b>
<dl>When run this creates a simple model of a cube intersected with a sphere
in the directory <tt>results</tt>.</dl>
<b><tt>sv_tst_2</tt></b>
<dl>This reads the model created by <tt>sv_tst_1</tt>, divides it, and
prints out some statistics on it.</dl>
<b><tt>sv_tst_g</tt></b>
<dl>This reads the model created by <tt>sv_tst_1 </tt>and plots a picture
of it.&nbsp; The graphics procedure runs as a separate thread, so you usually
get a `program finished' message before the graphics window appears.</dl>
<b><tt>voronoi_tst</tt></b>
<dl>This is a simple interactive program to build and plot <a href="#ab300">Voronoi
diagrams</a>.&nbsp; Start it with the coordinates of the bottom and top
corners of a box, then insert points into the diagram (or have the program
insert random ones for you) then plot the results.&nbsp; The plot window
menus have options to turn on and off the plotting of the points, the Delaunay
triangles, and the Voronoi territories.</dl>
<b><tt>refinery</tt></b>
<dl>When run, this creates the oil refinery model in the <tt>results</tt>
directory.</dl>
<b><tt>svlis</tt></b>
<dl>This is the result of compiling <tt>sv_edit.cxx</tt> and <tt>edittool.cxx</tt>.&nbsp;
It is a text-driven interactive model editor that allows you to create,
edit, view, and save svlis models.&nbsp; You should put the <tt>svlis</tt>
program in the executables path on any machine upon which svLis is installed
so that all users may run it. The <tt>svlis</tt> program has an option
to dump an interactive session into a file, which it can then replay at
a later date.&nbsp; Three such files exist in the <tt>data</tt> directory
just under the main svLis directory called <tt>r_pic_ux.log, r_pic_ms.log</tt>
and <tt>r_pic_mac.log </tt>for Unix, Microsoft, and Apple installations
respectively.&nbsp; If you run <tt>svlis</tt> on the appropriate one of
these it will ray-trace the refinery model (which you have to have created
first, of course).</dl>
<b><tt>sv_display</tt></b>
<dl>This displays a svlis model. Just type <tt>sv_display my_model.mod
</tt>(or
whatever the name of your model is) and this will create a picture of it.&nbsp;
This program should be put in the executables path of any system on which
svLis is installed so that all users can run it.&nbsp; Also, on Apple Macs
and Microsoft systems, you should set the system up so that clicking on
a <tt>.mod</tt> file runs this program with the file as input.&nbsp; You
can achieve the same effect on Unix systems with utilities like Xfm.&nbsp;
The svLis logo is provided in the <tt>data</tt> directory in various formats;
if you wish, you can configure the system to use this as an icon for svLis
<tt>.mod</tt>
files.&nbsp; This program reads command line arguments, and so is not much
use on a Mac, but it's included for completeness.&nbsp; You can of course
edit it if you want.</dl>
<b><tt>sv_convert</tt></b>
<dl>This updates svLis files from the previous version to the current version.&nbsp;
It will update files containing svLis attributes, primitives, sets, set
lists, or models.&nbsp; The current version is 3, so this will update svLis
Version 2 files.&nbsp; However, If you build it under svLis Version 2 it
should update Version 1 files; I have tried this and it works, but I have
not tested it extensively.&nbsp; This program reads command line arguments,
and so is not much use on a Mac, but it's included for completeness.&nbsp;
You can of course edit it if you want.</dl>
<b><tt>expt</tt></b>
<dl>This is just a test program that you can hack to try out quick svLis
ideas.&nbsp; Just write your code into <tt>expt.cxx;</tt> the distribution
provides you with a ready-made way of compiling and linking the executable,
so you don't have to bother about how to get that right.&nbsp; If you want
to start writing svLis code, the simplest thing to do is to copy one of
the other test programs into <tt>expt.cxx,</tt> edit it, make it, run it,
and see what happens.</dl>
</dl>

<hr><!--Navigation Panel--><a NAME="tex2html165" HREF="node10.html"></a><a NAME="tex2html165" HREF="node10.html"></a><a NAME="tex2html165" HREF="node10.html"></a><a NAME="tex2html165" HREF="node10.html"></a><a NAME="tex2html165" HREF="node10.html"></a><a NAME="tex2html165" HREF="node10.html"></a><a NAME="tex2html165" HREF="node10.html"></a><a NAME="tex2html165" HREF="node10.html"></a><a NAME="tex2html165" HREF="node10.html"></a><a NAME="tex2html165" HREF="node10.html"></a><a NAME="tex2html165" HREF="node10.html"></a><a NAME="tex2html165" HREF="node10.html"></a><a NAME="tex2html165" HREF="node10.html"></a><a NAME="tex2html165" HREF="node10.html"></a><a NAME="tex2html165" href="node10.html"></a><a NAME="tex2html165" href="node10.html"></a><a NAME="tex2html165" href="node10.html"></a><a NAME="tex2html165" href="node10.html"></a><a NAME="tex2html165" href="node10.html"></a><a NAME="tex2html165" href="node10.html"></a><a href="node10.html" NAME="tex2html165"><img SRC="next_motif.gif" ALT="next" BORDER=0 height=24 width=37 align=BOTTOM></a><a NAME="tex2html161" HREF="svi2.html"></a><a NAME="tex2html161" HREF="svi2.html"></a><a NAME="tex2html161" HREF="svi2.html"></a><a NAME="tex2html161" HREF="svi2.html"></a><a NAME="tex2html161" HREF="svi2.html"></a><a NAME="tex2html161" HREF="svi2.html"></a><a NAME="tex2html161" HREF="svi2.html"></a><a NAME="tex2html161" HREF="svi2.html"></a><a NAME="tex2html161" HREF="svi2.html"></a><a NAME="tex2html161" HREF="svi2.html"></a><a NAME="tex2html161" HREF="svi2.html"></a><a NAME="tex2html161" HREF="svi2.html"></a><a NAME="tex2html161" HREF="svi2.html"></a><a NAME="tex2html161" HREF="svi2.html"></a><a NAME="tex2html161" href="svi2.html"></a><a NAME="tex2html161" href="svi2.html"></a><a NAME="tex2html161" href="svi2.html"></a><a NAME="tex2html161" href="svi2.html"></a><a NAME="tex2html161" href="svi2.html"></a><a NAME="tex2html161" href="svi2.html"></a><a href="svi2.html" NAME="tex2html161"><img SRC="up_motif.gif" ALT="up" BORDER=0 height=24 width=26 align=BOTTOM></a><a NAME="tex2html155" HREF="node8.html"></a><a NAME="tex2html155" HREF="node8.html"></a><a NAME="tex2html155" HREF="node8.html"></a><a NAME="tex2html155" HREF="node8.html"></a><a NAME="tex2html155" HREF="node8.html"></a><a NAME="tex2html155" HREF="node8.html"></a><a NAME="tex2html155" HREF="node8.html"></a><a NAME="tex2html155" HREF="node8.html"></a><a NAME="tex2html155" HREF="node8.html"></a><a NAME="tex2html155" HREF="node8.html"></a><a NAME="tex2html155" HREF="node8.html"></a><a NAME="tex2html155" HREF="node8.html"></a><a NAME="tex2html155" HREF="node8.html"></a><a NAME="tex2html155" HREF="node8.html"></a><a NAME="tex2html155" href="node8.html"></a><a NAME="tex2html155" href="node8.html"></a><a NAME="tex2html155" href="node8.html"></a><a NAME="tex2html155" href="node8.html"></a><a NAME="tex2html155" href="node8.html"></a><a NAME="tex2html155" href="node8.html"></a><a href="node8.html" NAME="tex2html155"><img SRC="previous_motif.gif" ALT="previous" BORDER=0 height=24 width=63 align=BOTTOM></a><a NAME="tex2html163" HREF="node1.html"></a><a NAME="tex2html163" HREF="node1.html"></a><a NAME="tex2html163" HREF="node1.html"></a><a NAME="tex2html163" HREF="node1.html"></a><a NAME="tex2html163" HREF="node1.html"></a><a NAME="tex2html163" HREF="node1.html"></a><a NAME="tex2html163" HREF="node1.html"></a><a NAME="tex2html163" HREF="node1.html"></a><a NAME="tex2html163" HREF="node1.html"></a><a NAME="tex2html163" HREF="node1.html"></a><a NAME="tex2html163" HREF="node1.html"></a><a NAME="tex2html163" HREF="node1.html"></a><a NAME="tex2html163" HREF="node1.html"></a><a NAME="tex2html163" HREF="node1.html"></a><a NAME="tex2html163" href="node1.html"></a><a NAME="tex2html163" href="node1.html"></a><a NAME="tex2html163" href="node1.html"></a><a NAME="tex2html163" href="node1.html"></a><a NAME="tex2html163" href="node1.html"></a><a NAME="tex2html163" href="node1.html"></a><a href="node1.html" NAME="tex2html163"><img SRC="contents_motif.gif" ALT="contents" BORDER=0 height=24 width=65 align=BOTTOM></a><a NAME="tex2html164" HREF="node11.html"></a><a NAME="tex2html164" HREF="node11.html"></a><a NAME="tex2html164" HREF="node11.html"></a><a NAME="tex2html164" HREF="node11.html"></a><a NAME="tex2html164" HREF="node11.html"></a><a NAME="tex2html164" HREF="node11.html"></a><a NAME="tex2html164" HREF="node11.html"></a><a NAME="tex2html164" HREF="node11.html"></a><a NAME="tex2html164" HREF="node11.html"></a><a NAME="tex2html164" HREF="node11.html"></a><a NAME="tex2html164" HREF="node11.html"></a><a NAME="tex2html164" HREF="node11.html"></a><a NAME="tex2html164" HREF="node11.html"></a><a NAME="tex2html164" HREF="node11.html"></a><a NAME="tex2html164" href="node11.html"></a><a NAME="tex2html164" href="node11.html"></a><a NAME="tex2html164" href="node11.html"></a><a NAME="tex2html164" href="node11.html"></a><a NAME="tex2html164" href="node11.html"></a><a NAME="tex2html164" href="node11.html"></a><a href="node11.html" NAME="tex2html164"><img SRC="index_motif.gif" ALT="index" BORDER=0 height=24 width=43 align=BOTTOM></a>
<br><b>Next:</b><a href="node10.html">Bibliography</a> <b>Up:<a NAME="tex2html162" HREF="svi2.html"></a><a NAME="tex2html162" HREF="svi2.html"></a><a NAME="tex2html162" HREF="svi2.html"></a><a NAME="tex2html162" HREF="svi2.html"></a><a NAME="tex2html162" HREF="svi2.html"></a><a NAME="tex2html162" HREF="svi2.html"></a><a NAME="tex2html162" HREF="svi2.html"></a><a NAME="tex2html162" HREF="svi2.html"></a><a NAME="tex2html162" HREF="svi2.html"></a><a NAME="tex2html162" HREF="svi2.html"></a><a NAME="tex2html162" HREF="svi2.html"></a><a NAME="tex2html162" HREF="svi2.html"></a><a NAME="tex2html162" HREF="svi2.html"></a><a NAME="tex2html162" HREF="svi2.html"></a><a NAME="tex2html162" href="svi2.html"></a><a NAME="tex2html162" href="svi2.html"></a><a NAME="tex2html162" href="svi2.html"></a><a NAME="tex2html162" href="svi2.html"></a><a NAME="tex2html162" href="svi2.html"></a><a NAME="tex2html162" href="svi2.html"></a></b><a href="svi2.html" NAME="tex2html162">SvLis
Introduction</a> <b>Previous:</b><a href="node8.html">Afterword</a><!--End of Navigation Panel-->
<p><i>Adrian Bowyer</i>
<p>
<hr>
<br>&nbsp;
<br>&nbsp;
<br>
<br>
<center>
<p><img SRC="motto.gif" ALT="PERFICTA  PERFRACTA  QVAERENDO  PERFECTA" height=25 width=720></center>

<p><br>
<br>
<br>
<address>

<hr></address>

<br>&nbsp;</dl>

</body>
</html>
